(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{651:function(e,n,t){"use strict";t.r(n);var r=t(10),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"promise-面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-面试题"}},[e._v("#")]),e._v(" Promise 面试题")]),e._v(" "),t("p",[e._v("进入事件队列的函数有以下几种：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("setTimeout")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),t("li",[t("code",[e._v("setInterval")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),t("li",[t("code",[e._v("Promise")]),e._v(" 的 then` 函数回调，微任务（micro task）")]),e._v(" "),t("li",[t("code",[e._v("requestAnimationFrame")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),t("li",[e._v("事件处理函数，宏任务（macro task）\n"),t("strong",[e._v("微队列要优先于宏队列")])])]),e._v(" "),t("h3",{attrs:{id:"异步队列探索"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步队列探索"}},[e._v("#")]),e._v(" 异步队列探索")]),e._v(" "),t("p",[t("code",[e._v("Promise")]),e._v(" 回调与 "),t("code",[e._v("MutationObserver")]),e._v(" 回调会放入微队列中执行。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function onMicroTask(callback) {\n\t// 判断是否为 node 环境，process.nextTick 会执行微队列\n  if (process && process.nextTick) {\n    process.nextTick(callback);\n  } else if (MutationObserver) {\n    // 浏览器 MutationObserver 回调会放入微队列执行。\n    const ele = document.createElement("p");\n    const observer = new MutationObserver(callback);\n    observer.observe(ele, { attributes: true });\n    ele.style.width = 1;\n  } else {\n    setTimeout(callback, 0);\n  }\n}\n')])])]),t("h3",{attrs:{id:"判断是否为-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断是否为-promise"}},[e._v("#")]),e._v(" 判断是否为 Promise")]),e._v(" "),t("p",[e._v("只需要判断该对象是否满足 Promise A+ 规范")]),e._v(" "),t("p",[e._v("即对象是否存在且是否含有 then 方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function isPromise(obj) {\n  return !!(\n    obj && typeof obj === "object" && obj.then && typeof obj.then == "function"\n  );\n}\n')])])]),t("h3",{attrs:{id:"promise-手写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise-手写"}},[e._v("#")]),e._v(" Promise 手写")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const PENDDING = Symbol("pendding");\nconst FUFILLED = Symbol("fufilled");\nconst REJECTED = Symbol("rejected");\n\nfunction onMicroTask(callback) {\n    if (process && process.nextTick) {\n        process.nextTick(callback);\n    } else if (MutationObserver) {\n        const ele = document.createElement("p");\n        const observer = new MutationObserver(callback);\n        observer.observe(ele, { attributes: true });\n        ele.style.width = 1;\n    } else {\n        setTimeout(callback, 0);\n    }\n}\n\nfunction isPromise(obj) {\n    return !!(\n        obj && typeof obj === "object" && obj.then && typeof obj.then == "function"\n    );\n}\n\nclass MyPromise {\n    /**\n     *\n     * @param {Function} excutor 执行器，用来标记任务的状态\n     */\n    constructor(excutor) {\n        this._status = PENDDING; // 任务状态\n        this._value = undefined; // 任务数据\n        this._handlers = []; // 用来存放 then 的后续操作\n        // 如果 Promise 内部报错，将直接调用 reject\n        try {\n            // 由于我们的 resolve、reject 是在class中 会启用严格模式，且被直接调用，this 隐式丢失\n            excutor(this._resolve.bind(this), this._reject.bind(this));\n        } catch (reason) {\n            this._reject(reason);\n        }\n    }\n    /**\n     * 改变状态\n     * @param {Symbol} status\n     * @param {any} value\n     */\n    _changeStatus(status, value) {\n        // 状态只能由未决变为已决，且只能改变一次\n        if (this._status != PENDDING) return;\n        this._status = status;\n        this._value = value;\n    }\n    /**\n     *\n     * @param {any} data 标记任务成功\n     */\n    _resolve(data) {\n        this._changeStatus(FUFILLED, data);\n        this._runHandler();\n    }\n    /**\n     *\n     * @param {any} reason 标记任务失败\n     */\n    _reject(reason) {\n        this._changeStatus(REJECTED, reason);\n        this._runHandler();\n    }\n    /**\n     * 将后续的处理放入执行栈中\n     * @param {*} excutor\n     * @param {*} status\n     * @param {*} resolve\n     * @param {*} reject\n     */\n    _pushState(excutor, status, resolve, reject) {\n        this._handlers.push({\n            excutor,\n            status,\n            resolve,\n            reject,\n        });\n    }\n    /**\n     * 调用执行栈中的函数。\n     */\n    _runHandler() {\n        if (this._status === PENDDING) return;\n        while (this._handlers.length > 0) {\n            const handler = this._handlers[0];\n            this._callHandler(handler);\n            this._handlers.shift();\n        }\n    }\n    /**\n     * 执行处理函数\n     */\n    _callHandler({ excutor, status, resolve, reject }) {\n        onMicroTask(() => {\n            if (this._status != status) return;\n            if (typeof excutor != "function") {\n                this._status === FUFILLED ? resolve(this._value) : reject(this_value);\n                return;\n            }\n            try {\n                const result = excutor(this._value);\n                if (isPromise(result)) {\n                    result.then(resolve, reject);\n                } else {\n                    resolve(result);\n                }\n            } catch (err) {\n                reject(err);\n            }\n        });\n    }\n    /**\n     *\n     * @param {*} onFufilled\n     * @param {*} onRejected\n     */\n    then(onFufilled, onRejected) {\n        return new MyPromise((resolve, reject) => {\n            this._pushState(onFufilled, FUFILLED, resolve, reject);\n            this._pushState(onRejected, REJECTED, resolve, reject);\n            this._runHandler();\n        });\n    }\n    /**\n     * 复用 then 函数\n     * @param {Function} onRejected 失败回调 \n     * @returns \n     */\n    catch(onRejected) {\n        return this.then(null, onRejected)\n    }\n\n    finally(onSettled) {\n        return this.then((data) => {\n            onSettled();\n            return data;\n        }, (reason) => {\n            onSettled();\n            throw reason;\n        })\n    }\n    /**\n     * 特殊情况：\n     * 1、传入的data本身就是ES6的Promise对象，直接返回这个Promise\n     * 2、传入的data是PromiseLike（即符合Promise A+ 规范的），返回新的Promise，状态和其保持一致。\n     * 3、返回一个成功的Promise\n     * @param {*} data \n     */\n    static resolve(data) {\n        if (data instanceof MyPromise) {\n            return data;\n        }\n        return new MyPromise((resolve, reject) => {\n            if (isPromise(data)) {\n                data.then(resolve, reject)\n            } else {\n                resolve(data)\n            }\n        })\n    }\n    /**\n     * 返回一个拒绝的Promise\n     * @param {*} reason \n     */\n    static reject(reason) {\n        return new MyPromise((resolve, reject) => {\n            reject(reason)\n        })\n    }\n\n    /**\n     * 返回一个新的Promise\n     * 该Promise的状态取决于proArr的执行\n     * proArr是一个迭代器，包含多个Promise\n     * 全部Promise成功，则返回的Promise成功，数据为所有Promise成功的数据，并且顺序是按照传入的顺序\n     * 只要有一个Promise失败，则返回的Promise失败，原因是第一个失败的Promise的原因\n     * @param {Iterator} proArr \n     */\n    static all(proArr) {\n        return new MyPromise((resolve, reject) => {\n            try {\n                let count = 0;\n                let fufilledNums = 0;\n                const proResults = new Array();\n                for (const p of proArr) {\n                    let cur = count;\n                    count++;\n                    MyPromise.resolve(p).then((data) => {\n                        fufilledNums++;\n                        proResults[cur] = data;\n                        if (fufilledNums == count) {\n                            resolve(proResults)\n                        }\n                    }, reject)\n                }\n                if (count == 0) {\n                    resolve(proResults)\n                }\n            } catch (reason) {\n                reject(reason)\n            }\n        })\n    }\n    /**\n     * 等待所有的Promise有结果之后\n     * 该方法返回的Promise完成\n     * 并且按照顺序将所有结果汇总\n     * @param {Iterator} proArr \n     */\n    static allSettled(proArr) {\n        var pros = [];\n        for (let p of proArr) {\n            pros.push(\n                MyPromise.resolve(p).then(data => ({\n                    status: FUFILLED,\n                    value: data\n                }), reason => ({\n                    status: REJECTED,\n                    reason\n                }))\n            )\n        }\n        return MyPromise.all(pros)\n    }\n\n    /**\n     * \n     * @param {Iterator} proArr \n     */\n    static race(proArr) {\n        return new MyPromise((resolve, reject) => {\n            for (let p of proArr) {\n                MyPromise.resolve(p).then(resolve, reject)\n            }\n        })\n    }\n}\n\nconst p = new MyPromise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(1);\n    }, 1000);\n});\n\n\nMyPromise.all([\n    MyPromise.resolve(1),\n    MyPromise.resolve(2),\n    MyPromise.resolve(3),\n    4,\n]).then(data => {\n    console.log(data);\n}, reason => {\n\n})\n')])])]),t("p",[e._v("其中 "),t("code",[e._v("MyPromise.resolve")]),e._v("、"),t("code",[e._v("MyPromise.reject")]),e._v("、"),t("code",[e._v("MyPromise.all")]),e._v("、"),t("code",[e._v("MyPromise.allSettled")]),e._v("、"),t("code",[e._v("MyPromise.race")]),e._v(" 为 "),t("code",[e._v("Promise")]),e._v(" 的静态方法。")])])}),[],!1,null,null,null);n.default=s.exports}}]);