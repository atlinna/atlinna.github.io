(window.webpackJsonp=window.webpackJsonp||[]).push([[127],{715:function(e,t,a){"use strict";a.r(t);var n=a(10),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"reactivity-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reactivity-api"}},[e._v("#")]),e._v(" Reactivity Api")]),e._v(" "),a("p",[e._v("何为 Reactivity Api？")]),e._v(" "),a("p",[e._v("这是 Vue3 中的 重中之重")]),e._v(" "),a("p",[e._v("他涵盖了 Vue3 中的响应式功能")]),e._v(" "),a("p",[e._v("Vue2中是如何实现数据响应的？")]),e._v(" "),a("p",[e._v("我们是要配置一个 data 对象，这个对象自动的就会变成响应式对吧 这个过程叫 "),a("strong",[e._v("注入")])]),e._v(" "),a("p",[e._v("但是 Vue3 不同，它相当于将响应式这个概念抛出来，也就是我们的 reactivity api，我们通过调用 reactivity api 来使我们的数据变为响应式数据。")]),e._v(" "),a("ul",[a("li",[e._v("reactive")]),e._v(" "),a("li",[e._v("readonly")]),e._v(" "),a("li",[e._v("ref")]),e._v(" "),a("li",[e._v("computed")])]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("-- reactive")]),e._v(" "),a("p",[e._v("-作用：深度代理对象中的所有成员，")]),e._v(" "),a("p",[e._v("-类型：对象代理")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive } from "vue";\nconst obj = { a: 1, b: 2 };\nconst state = reactive(obj);\n')])])]),a("p",[e._v("这样我们就能得到一个代理对象 state。")]),e._v(" "),a("p",[e._v("如果我们创建一个数值，一个常量。然后通过 reactive 来进行代理，看会发生什么。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive } from "vue";\nconst obj = { a: 1, b: 2 };\nconst count = 1;\nconst state = reactive(obj);\nconst state1 = reactive(count);\nconsole.log(state);\nconsole.log(state1);\n')])])]),a("p",[e._v("并不会报错，但是 Vue 给了我们一个警告， value cannot be made reactive，")]),e._v(" "),a("p",[e._v("他说啊 这个类型不能被 reactive 代理。")]),e._v(" "),a("p",[e._v("通过 state 我们可以发现：")]),e._v(" "),a("p",[e._v("state.a 是 1，")]),e._v(" "),a("p",[e._v("state.b 是 2，")]),e._v(" "),a("p",[e._v("state 是一个 Proxy， 是一个代理对象，它代理的使我们的普通对象，由于它是一个 Proxy，所以 如果我们为 state 的成员进行赋值，他是可以收到通知的。")]),e._v(" "),a("p",[e._v("通过上面的例子我们还可以观察到，我们实现一个响应式并没有依赖组件，以前 vue2 的时候我们需要配置 data 对象，但是现在呢 ？ 连组件的一根毛都没看见，也就是说现在的 响应式完全是抽离出来，与组件没有任何关系的。")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("-- readonly")]),e._v(" "),a("p",[e._v("-作用：只能读取代理对象中的成员，但是不能修改")]),e._v(" "),a("p",[e._v("-类型：对象代理（可以传入一个对象或者一个 proxy）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const objOnly = readonly(obj);\nobjOnly.a = 2;\nconsole.log(objOnly);\n")])])]),a("p",[e._v("我们可以看到控制台上输出了警告，意思是给 a 属性赋值失败，因为目标是一个只读的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const stateOnly = readonly(state);\nstate.a = 2;\nconsole.log(stateOnly);\n")])])]),a("p",[e._v("我们看这个例子，通过 readonly 代理 state，然后修改 state 的属性 a。")]),e._v(" "),a("p",[e._v("没有警告，赋值成功对吧，")]),e._v(" "),a("p",[e._v("因为 stateOnly --\x3e 代理的 state --\x3e 代理的 对象 obj")]),e._v(" "),a("p",[e._v("所以如果对象 obj 或者 state 改变 stateOnly 都会跟着改变")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("-- ref")]),e._v(" "),a("p",[e._v("首先先来说一下为什么会有 ref 这个东西存在，因为我们前面已经看到，reactive，readonly存在，且可以将我们的数据变为响应式了对吧？那为什么还要有 ref 呢？")]),e._v(" "),a("p",[e._v("可以想到的是，随着我们 reactivity api 的抽离，肯定会有一些数据 如一个 number 啊 一个string 字符串啊 这样的数据代理，但是我们上面已经实验过 reactive 不能够对非对象的数据进行代理。 所以 ref 出现了，目的就是解决我们代理 普通数据的需求。")]),e._v(" "),a("p",[e._v("ref 的原理就是创建一个对象，然后把值放到对象的 value 属性里面。")]),e._v(" "),a("p",[e._v("我们学习过 Es 6 知道了 对象中存在访问器 getter 和 setter")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("{\n\tget value(){\n\t\t...\n\t},\n\tset value(val){\n\t  ...\n\t}\n}\n")])])]),a("p",[e._v("那么 ref 的实质是什么？ 无非就是通过访问器实现，当你读取的时候使用 get 方法，然后当你赋值的时候 运行 set 方法。但是不是盲目的赋值，会判断一下数据的类型。")]),e._v(" "),a("p",[a("strong",[e._v("如果数据是一个 proxy。")])]),e._v(" "),a("p",[e._v("那么直接将 value 的值赋值为这个代理，没有必要创建一个代理去代理它对吧")]),e._v(" "),a("p",[e._v("我们可以看下")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const stateRef = ref(state);\nconsole.log(stateRef.value === state);\n")])])]),a("p",[e._v("我们看到结果是 true 对吧。")]),e._v(" "),a("p",[a("strong",[e._v("如果数据是普通类型。")])]),e._v(" "),a("p",[e._v("普通数据的话，vue 会创建一个对象，然后将这个值赋给 value 属性，然后返回这个代理。")]),e._v(" "),a("p",[e._v("这样就完成了普通数据的响应式。")]),e._v(" "),a("p",[a("strong",[e._v("如果数据是一个对象。")])]),e._v(" "),a("p",[e._v("如果是对象的话就不能直接想普通对象一样操作了，因为 赋值给 value 对象后，value 还是一个普通的对象，无法进行响应式 对吧？外面是代理，里面是对象，相当于啥也没干···")]),e._v(" "),a("p",[e._v("所以呢 这个时候，它会调用一下 reactive 将对象变为代理。")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("-- computed")]),e._v(" "),a("p",[e._v("computed 呢也很常用，它呢接收一个函数，然后根据情况来判断是否会运行")]),e._v(" "),a("p",[e._v("-类型：返回的是一个代理")]),e._v(" "),a("p",[e._v("什么叫根据情况来判断是否会运行呢？")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const sum = computed(() => {\n  console.log("start it");\n  return state.a + state.b;\n});\n\nconsole.log(sum.value);\nconsole.log(sum.value);\n')])])]),a("p",[e._v("现在呢我们新增一个 computed 让他求和 state 中的 ab 属性，我们看下 computed 的函数会运行几次呢？")]),e._v(" "),a("p",[e._v("答案是1次！")]),e._v(" "),a("p",[e._v("为什么会这样呢？")]),e._v(" "),a("p",[e._v("vue 会收集依赖，同时缓存这个结果，当我第一次运行的时候，会执行函数搜集这个依赖，依赖的 state 中的 a,b 属性。返回我们的代理结果。")]),e._v(" "),a("p",[e._v("当我们第二次运行的时候，vue一看 诶 哥们 你这没有变化呀，那我把之前的结果给你吧！")]),e._v(" "),a("p",[e._v("那么什么时候会再次运行呢？ 是不是当我们函数中依赖的响应式数据发生变化才会执行")]),e._v(" "),a("p",[e._v("也就是 state.a 或 state.b 发生变化的时候。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(sum.value);\nstate.b = 3\nconsole.log(sum.value);\n")])])]),a("p",[e._v("完美运行。")]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("使用 reactive(...) 的到的 是一个 代理对象")]),e._v(" "),a("p",[e._v("const state = reactive({a:1,b:2}) // state 是一个代理")]),e._v(" "),a("p",[e._v("如果使用 ref(...) 得到的是一个 代理对象")]),e._v(" "),a("p",[e._v("const stateRef = ref({a:1,b:2}) // stateRef.value 是一个代理")]),e._v(" "),a("p",[e._v("两种形式")]),e._v(" "),a("ul",[a("li",[e._v("如果想让一个对象变为响应式数据，可以使用 reactive 或 ref")]),e._v(" "),a("li",[e._v("如果想让一个对象的所有属性只读，可以使用 readonly")]),e._v(" "),a("li",[e._v("如果想让一个非对象数据变为响应式数据，可以使用 ref")]),e._v(" "),a("li",[e._v("如果要根据已有的响应式数据得到一个新的响应式数据，可以使用 computed")])]),e._v(" "),a("hr"),e._v(" "),a("p",[e._v("ok 接下来我们联系一下")]),e._v(" "),a("p",[e._v("Problem -1")]),e._v(" "),a("p",[e._v("请问下面 console.log 输出了什么")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, readonly, ref, computed } from "vue";\n\nconst state = reactive({ firstName: "Xiao Ming", lastName: "Wang" });\n\nconst fullName = computed(() => {\n  console.log("changed");\n  return `${state.lastName},${state.firstName}`;\n});\nconsole.log("state ready");\nconsole.log("fullname is", fullName.value);\nconsole.log("fullname is", fullName.value);\n\nconst imState = readonly(state);\nconsole.log(imState === state);\n\nconst stateRef = ref(state);\nconsole.log(stateRef.value === state);\n\nstate.firstName = "Xiao Hong";\nstate.lastName = "Li";\n\nconsole.log(imState.firstName, imState.lastName);\nconsole.log("fullname is", fullName.value);\nconsole.log("fullname is", fullName.value);\n\nconst imState2 = readonly(stateRef);\nconsole.log(imState2.value === stateRef.value);\n')])])]),a("p",[e._v("可以自己写出来然后对照一下")]),e._v(" "),a("p",[e._v("Problem - 2")]),e._v(" "),a("p",[e._v("补全 useUser 函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, readonly, ref, computed } from "vue";\n\nfunction useUser() {\n  // 在这里补全函数\n  return {\n    user, // 这是一个只读的用户对象，响应式数据，默认为一个空对象\n    setUserName, // 这是一个函数，传入用户姓名，用于修改用户的名称\n    setUserAge, // 这是一个函数，传入用户年龄，用户修改用忽的年龄\n  };\n}\n\n')])])]),a("p",[e._v("答案：这里 reactive 或者 ref 都是可以的 注意好 不要自己乱了就行 因为 ref 的 value 属性才是代理。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, readonly, ref, computed } from "vue";\n\nfunction useUser() {\n  // 在这里补全函数\n  const userProp = reactive({});\n  const user = readonly(userProp);\n  const setUserName = (name) => {\n    userProp.name = name;\n  };\n  const setUserAge = (age) => {\n    userProp.age = age;\n  };\n\n  return {\n    user, // 这是一个只读的用户对象，响应式数据，默认为一个空对象\n    setUserName, // 这是一个函数，传入用户姓名，用于修改用户的名称\n    setUserAge, // 这是一个函数，传入用户年龄，用户修改用忽的年龄\n  };\n}\n\nlet u = useUser();\nconst { user } = u;\nconsole.log(user);\nconsole.log(user.name);\nu.setUserName("Lisa");\nconsole.log(user.name);\n')])])]),a("p",[e._v("Problem - 3")]),e._v(" "),a("p",[e._v("响应式数据防抖")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, ref, readonly } from "vue";\n\nfunction useDebounce(obj, duration) {\n  const origin = reactive(obj);\n  const value = readonly(origin);\n  let timer = null;\n  const setValue = (val) => {\n    if (timer) {\n      clearTimeout(timer);\n    }\n    timer = setTimeout(() => {\n      Object.entries(val).forEach(([k, v]) => {\n        origin[k] = v;\n      });\n      console.log(value)\n    }, duration);\n  };\n\n  return {\n    value,\n    setValue,\n  };\n}\n')])])]),a("hr"),e._v(" "),a("h3",{attrs:{id:"监听"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监听"}},[e._v("#")]),e._v(" 监听")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("watchEffect")]),e._v(" "),a("p",[e._v("watchEffect 接收一个函数，函数呢， 首先会执行一次，同时搜集依赖，如果依赖项改变，则会再次执行函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, watchEffect } from "vue";\n\nconst stateOrigin = reactive({ a: 1, b: 2 });\n\nconst stop = watchEffect(() => {\n  console.log(stateOrigin.a);\n});\n\nstateOrigin.a++;\n\nstop()\n')])])]),a("p",[e._v("这里呢 如果 执行 stop 则会终止 watchEffect")])]),e._v(" "),a("li",[a("p",[e._v("watch")]),e._v(" "),a("p",[e._v("同 Vue2 中的 $watch")]),e._v(" "),a("p",[e._v("首先我们看下 watch 如何去监听数据")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, watchEffect, watch } from "vue";\n\nconst stateOrigin = reactive({ a: 1, b: 2 });\n\nwatch(stateOrigin, (newValue, oldValue) => {\n  console.log("new", newValue.a, "old", oldValue.a);\n});\n\nstateOrigin.a++;\n\n')])])]),a("p",[e._v("我们看到结果 新旧值是一个样的 这是为什么 因为我们监听的是一个代理对象。那么我们试试去监听它里面的值达到我们想要的效果。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('watch(stateOrigin.a, (newValue, oldValue) => {\n  console.log("new", newValue.a, "old", oldValue.a);\n});\n\n')])])]),a("p",[e._v("但是当我们将监听改为监听 stateOrigin 的 a 属性时，vue 给了我们一个警告，意思是我们不能监听一个 1，哦 原来 它会现将这个表达式算出来，再改一改,既然它会计算这个表达式，那我们就使用函数返回这个 a 属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('watch(\n  () => stateOrigin.a,\n  (newValue, oldValue) => {\n    console.log("new", newValue, "old", oldValue);\n  }\n);\n\nstateOrigin.a++;\n')])])]),a("p",[e._v("测试成功！")]),e._v(" "),a("p",[e._v("ok 当然你也可以直接监听一个 ref")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, watchEffect, watch, ref } from "vue";\n\nconst stateOrigin = reactive({ a: 1, b: 2 });\nconst countRef = ref(0);\n\nwatch(\n  () => countRef.value,\n  (newValue, oldValue) => {\n    console.log("new", newValue, "old", oldValue);\n  }\n);\n\ncountRef.value++;\n\n')])])]),a("p",[e._v("注意 这里 我们可以直接监听一个 ref 因为 他是一个对象，可以被监听")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('watch(\n  countRef,\n  (newValue, oldValue) => {\n    console.log("new", newValue, "old", oldValue);\n  }\n);\n\ncountRef.value++;\n\n')])])]),a("p",[e._v("同时 watch 是可以监听多个属性的")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import { reactive, watchEffect, watch, ref } from "vue";\n\nconst stateOrigin = reactive({ a: 1, b: 2 });\nconst countRef = ref(0);\n\nwatch(\n  [countRef, stateOrigin],\n  ([newValue1, newValue2], [oldValue1, oldValue2]) => {\n    console.log("new1", newValue1, "old1", oldValue1);\n    console.log("new2", newValue2, "old2", oldValue2);\n  }\n);\n\ncountRef.value++;\nstateOrigin.a++;\n\n')])])]),a("p",[e._v("Watch 和 watchEffect 都是 微队列 异步执行的 全部是等到你的 依赖项执行完毕，然后才会执行监听里面 的回调函数。")]),e._v(" "),a("p",[e._v("然后 什么情况下建议使用 watch 呢")]),e._v(" "),a("ul",[a("li",[e._v("如果 你不希望监听一上来就执行，使用 watch")]),e._v(" "),a("li",[e._v("如果 你希望得到旧值，使用 watch")]),e._v(" "),a("li",[e._v("如果要同时监听多个值")])]),e._v(" "),a("p",[e._v("否则 都使用 watchEffect")])])]),e._v(" "),a("p",[a("strong",[e._v("判断：")])]),e._v(" "),a("ul",[a("li",[e._v("isProxy 判断某个数据是否是 reactive 或 readonly")]),e._v(" "),a("li",[e._v("isReactive 判断某个数据是否是通过 reactive 创建的")]),e._v(" "),a("li",[e._v("isReadonly 判断某个数据是否是通过 readonly 创建的")]),e._v(" "),a("li",[e._v("isRef 判断某个数据是否是一个 ref 对象")])]),e._v(" "),a("p",[a("strong",[e._v("转换：")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("unRef 等同于 isRef(ref)? ref.value:value")])]),e._v(" "),a("li",[a("p",[e._v("toRef 得到一个响应式对象某个属性的 ref 格式")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('const stateOrigin = reactive({ a: 1, b: 2 });\nconst countRef = ref(0);\n\nconst aRef = toRef(stateOrigin, "a");\nconsole.log(aRef.value)\n\n')])])]),a("p",[e._v("就相当于将 reactive 中的属性值拿出来然后创建了一个 ref")])]),e._v(" "),a("li",[a("p",[e._v("toRefs() 将一个对象中的所有成员都变为 ref")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setup(){\n\tconst state1Origin = reactive({a:1})\n\tconst state1Origin = reactive({b:2})\n\t\n\treturn{\n\t  ...state1Origin, // lose reactivity\n\t  ...state2Origin, // lose reactivity\n\t}\n}\n")])])]),a("p",[e._v("如上,我们在 setup 中 会遇到合并的需求，但是这样一扩展出来 就变成了普通对象，失去了响应式")]),e._v(" "),a("p",[e._v("这个时候我们怎么做呢，我们是不是可以给要扩展的对象用 toRefs包起来 这样，合并之后每个成员都是一个 ref。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("setup(){\n\tconst state1Origin = reactive({a:1})\n\tconst state1Origin = reactive({b:2})\n\t\n\treturn{\n\t  ...toRefs(state1Origin), // lose reactivity\n\t  ...toRefs(state2Origin), // lose reactivity\n\t}\n}\n")])])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);