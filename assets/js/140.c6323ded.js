(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{726:function(t,s,r){"use strict";r.r(s);var v=r(10),_=Object(v.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"ts-如何使用模块化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ts-如何使用模块化"}},[t._v("#")]),t._v(" TS 如何使用模块化")]),t._v(" "),r("p",[t._v("统一使用 ESM 的导入导出标准")]),t._v(" "),r("p",[t._v("即 export 或 export default 导出")]),t._v(" "),r("p",[t._v("使用 import 导入")]),t._v(" "),r("p",[t._v("但是建议使用 export 来导出，因为默认导出无法进行推导，享受不到智能提示。")]),t._v(" "),r("p",[r("strong",[t._v("注意：不要在后面添加 .ts 后缀名")])]),t._v(" "),r("h3",{attrs:{id:"编译结果中的模块化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编译结果中的模块化"}},[t._v("#")]),t._v(" 编译结果中的模块化")]),t._v(" "),r("p",[t._v("可以在 tsconfig.json 中配置要使用的模块化标准")]),t._v(" "),r("p",[t._v("TS中的模块化在编译结果中：")]),t._v(" "),r("ol",[r("li",[t._v("如果编译结果的模块化标准是 ES6 则没有区别。")]),t._v(" "),r("li",[t._v("如果编译结果的模块化标准是 commonjs，则导出的声明会变成 exports 的属性，默认的导出会变成 exports 的 default 属性；")])]),t._v(" "),r("h3",{attrs:{id:"在ts-中使用-commonjs-模块化规范"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在ts-中使用-commonjs-模块化规范"}},[t._v("#")]),t._v(" 在TS 中使用 CommonJS 模块化规范")]),t._v(" "),r("p",[t._v("可以使用。但是书写方式需要改变")]),t._v(" "),r("p",[t._v("导出：export = xxx")]),t._v(" "),r("p",[t._v("导入：import xxx from xxx")]),t._v(" "),r("h3",{attrs:{id:"模块解析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#模块解析"}},[t._v("#")]),t._v(" 模块解析")]),t._v(" "),r("p",[t._v("TS 中有两种模块解析策略")]),t._v(" "),r("ul",[r("li",[t._v("classic 经典")]),t._v(" "),r("li",[t._v("node 解析策略 (唯一的区别就是将 js 替换为 ts)\n"),r("ul",[r("li",[t._v("相对路径 require('./xxx')")]),t._v(" "),r("li",[t._v("非相对模块 require('xxx')")])])])])])}),[],!1,null,null,null);s.default=_.exports}}]);