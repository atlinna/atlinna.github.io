(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{634:function(t,v,_){"use strict";_.r(v);var a=_(10),i=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"css-中的单位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css-中的单位"}},[t._v("#")]),t._v(" CSS 中的单位")]),t._v(" "),_("p",[t._v("绝对单位：cm， mm， Q，in ，px"),_("br"),t._v("\n相对单位：em， rem， vw ，vh ，\npx 与 em 的区别\npx 是相对于屏幕分辨率而言的一个绝对单位，同一设备下他们的物理长度不变，但是不同设备下的长度意义不同。")]),t._v(" "),_("p",[t._v("em 是相对长度单位，具体大小要根据父元素来计算。")]),t._v(" "),_("h3",{attrs:{id:"盒子居中"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#盒子居中"}},[t._v("#")]),t._v(" 盒子居中")]),t._v(" "),_("p",[t._v("transform\nvertical-align\nmargin\ndisplay\nposition")]),t._v(" "),_("h3",{attrs:{id:"隐藏元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#隐藏元素"}},[t._v("#")]),t._v(" 隐藏元素")]),t._v(" "),_("ul",[_("li",[t._v("完全隐藏 display：none，hidden 标签属性")]),t._v(" "),_("li",[t._v("视觉隐藏 visibility：hidden")]),t._v(" "),_("li",[t._v("语义隐藏 aira-hidden:true")])]),t._v(" "),_("h3",{attrs:{id:"定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[t._v("#")]),t._v(" 定位")]),t._v(" "),_("p",[t._v("absolute 会将 盒子变为 block -- 针对行内元素\nposition 的值 有哪些？")]),t._v(" "),_("ul",[_("li",[t._v("static --》 正常定位")]),t._v(" "),_("li",[t._v("relative --》相对定位 相对当前位置进行定位")]),t._v(" "),_("li",[t._v("absolute --》绝对定位，以距离自己最近的定位元素进行定位")]),t._v(" "),_("li",[t._v("fixed --》固定于视口进行定位")]),t._v(" "),_("li",[t._v("sticky --》粘性定位")])]),t._v(" "),_("h4",{attrs:{id:"sticky-粘性定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sticky-粘性定位"}},[t._v("#")]),t._v(" sticky 粘性定位")]),t._v(" "),_("p",[t._v("position ：sticky 可以设置 left\\top\\right\\bottom 4个阈值，表示如果小于阈值的话则保持当前阈值距离。")]),t._v(" "),_("h3",{attrs:{id:"bfc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[t._v("#")]),t._v(" BFC")]),t._v(" "),_("h4",{attrs:{id:"介绍bfc及其应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍bfc及其应用"}},[t._v("#")]),t._v(" 介绍BFC及其应用")]),t._v(" "),_("p",[t._v("BFC，指的是一个独立的布局环境，BFC内部的元素布局与外部互不影响。\n触发BFC 的方式很多，常见的有：")]),t._v(" "),_("ul",[_("li",[t._v("设置浮动")]),t._v(" "),_("li",[t._v("overflow 设置为 auto、scroll、hidden")]),t._v(" "),_("li",[t._v("position 设置为 absolute、fixed\n常见的BFC应用有：")]),t._v(" "),_("li",[t._v("解决浮动元素令父元素丢失高度问题。")]),t._v(" "),_("li",[t._v("解决非浮动元素被浮动元素覆盖问题")]),t._v(" "),_("li",[t._v("解决外边距垂直方向重合的问题。")])]),t._v(" "),_("h4",{attrs:{id:"介绍下-bfc、ifc、gfc-和-ffc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍下-bfc、ifc、gfc-和-ffc"}},[t._v("#")]),t._v(" 介绍下 BFC、IFC、GFC 和 FFC")]),t._v(" "),_("ul",[_("li",[t._v("BFC 块级格式化上下文")]),t._v(" "),_("li",[t._v("IFC  行内格式化上下文")]),t._v(" "),_("li",[t._v("GFC 网格布局格式化上下文")]),t._v(" "),_("li",[t._v("FFC 弹性格式化上下文")])]),t._v(" "),_("h3",{attrs:{id:"css-属性计算"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css-属性计算"}},[t._v("#")]),t._v(" CSS 属性计算")]),t._v(" "),_("h4",{attrs:{id:"计算过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算过程"}},[t._v("#")]),t._v(" 计算过程")]),t._v(" "),_("ul",[_("li",[t._v("确定生命值：参考样式表中没有冲突的声明，作为 CSS 属性值")]),t._v(" "),_("li",[t._v("层叠冲突： 对样式表有冲突的声明使用层叠规则，确定  CSS 属性值")]),t._v(" "),_("li",[t._v("使用继承： 对仍然没有值的属性，若可以继承则继承父元素的值")]),t._v(" "),_("li",[t._v("使用默认值： 对仍然没有值的属性，全部使用默认属性值")])]),t._v(" "),_("h4",{attrs:{id:"简述一下-css-中的层叠规则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述一下-css-中的层叠规则"}},[t._v("#")]),t._v(" 简述一下 CSS 中的层叠规则")]),t._v(" "),_("p",[t._v("CSS 中当属性值发生冲突时，通过层叠规则来计算出最终的属性值，层叠规则可以分为3块：")]),t._v(" "),_("ul",[_("li",[t._v("重要性（Importance）：！important")]),t._v(" "),_("li",[t._v("专用型（Specificity）：指根据权重计算")]),t._v(" "),_("li",[t._v("源代码次序（Souce order）：后面的会覆盖前面的")])]),t._v(" "),_("h3",{attrs:{id:"css-引入方式有哪些-link-和-import-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css-引入方式有哪些-link-和-import-的区别"}},[t._v("#")]),t._v(" CSS 引入方式有哪些？ link 和 @import 的区别？")]),t._v(" "),_("p",[t._v("CSS 引入方式有：")]),t._v(" "),_("ul",[_("li",[t._v("外联 通过 link 标签")]),t._v(" "),_("li",[t._v("内联 在head 内 使用 style 标签")]),t._v(" "),_("li",[t._v("嵌入 在元素内 通过 style 属性")])]),t._v(" "),_("p",[t._v("link 与 @import 区别：")]),t._v(" "),_("ol",[_("li",[t._v("link 属于 HTML 标签， 而 @import 完全是 CSS 提供的一种方式。")]),t._v(" "),_("li",[t._v("加载顺序不同 只有当使用了 @import 的 css 文件下载完成并解析后，浏览器才知道还存在其他的 CSS 文件需要下载")]),t._v(" "),_("li",[t._v("兼容性 已完全兼容")]),t._v(" "),_("li",[t._v("当使用JS 控制 DOOM 去改变样式的时候，只能使用link 标签，因为@import不是DOM 可以控制的。\n使用@import 会引起并行文件下载错乱。")])]),t._v(" "),_("h3",{attrs:{id:"transition"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#transition"}},[t._v("#")]),t._v(" transition")]),t._v(" "),_("p",[t._v("transition 并不是所有都能过度，只有存在中点值的才能进行过度\ndocument 提供 ontransitionend 事件来监听元素过度结束")]),t._v(" "),_("h3",{attrs:{id:"animation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#animation"}},[t._v("#")]),t._v(" animation")]),t._v(" "),_("p",[t._v("提供了多个状态的监听事件")]),t._v(" "),_("ul",[_("li",[t._v("animationstart CSS 动画开始后触发")]),t._v(" "),_("li",[t._v("animationiteration CSS 动画重复播放触发")]),t._v(" "),_("li",[t._v("animationend CSS 动画完成后触发")])]),t._v(" "),_("h3",{attrs:{id:"简述-css3-中新增的变形如何使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简述-css3-中新增的变形如何使用"}},[t._v("#")]),t._v(" 简述 CSS3 中新增的变形如何使用")]),t._v(" "),_("p",[t._v("分为 2D 和 3D")]),t._v(" "),_("ul",[_("li",[t._v("具有 x/y 的函数：translateX、天然水拉特Y、scaleX、scaleY、skewX、skewY")]),t._v(" "),_("li",[t._v("2D变形函数： translate、scale、rotate、skew、matrix")]),t._v(" "),_("li",[t._v("3D变形函数：rotateX、Y，rotate3d、translateZ、translate3d、scaleZ、scale3d")])]),t._v(" "),_("p",[t._v("还有一些其他的变形属性：")]),t._v(" "),_("ul",[_("li",[t._v("transform")]),t._v(" "),_("li",[t._v("transform-origin")]),t._v(" "),_("li",[t._v("transform-style")]),t._v(" "),_("li",[t._v("perspective")]),t._v(" "),_("li",[t._v("perspective-origin")]),t._v(" "),_("li",[t._v("backface-visibility")])]),t._v(" "),_("h3",{attrs:{id:"文字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#文字"}},[t._v("#")]),t._v(" 文字")]),t._v(" "),_("p",[t._v("word-wrap\nword-break\nwhite-space")]),t._v(" "),_("h3",{attrs:{id:"什么是渐进式渲染"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是渐进式渲染"}},[t._v("#")]),t._v(" 什么是渐进式渲染")]),t._v(" "),_("p",[t._v("也被称为惰性渲染，指为了提高用户感知的加载速度，以尽快的速度来呈现页面的技术。")]),t._v(" "),_("ul",[_("li",[t._v("骨架屏")]),t._v(" "),_("li",[t._v("图片懒加载")]),t._v(" "),_("li",[t._v("图片占位符")]),t._v(" "),_("li",[t._v("资源拆分")])]),t._v(" "),_("h3",{attrs:{id:"css-渲染性能优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css-渲染性能优化"}},[t._v("#")]),t._v(" CSS 渲染性能优化")]),t._v(" "),_("ul",[_("li",[t._v("尽量使用id选择器 id唯一")]),t._v(" "),_("li",[t._v("避免深层次的选择器嵌套")]),t._v(" "),_("li",[t._v("尽量避免使用属性选择器，匹配速度慢")]),t._v(" "),_("li",[t._v("使用渐进增强的方案")]),t._v(" "),_("li",[t._v("遵守CSSLint 规则")]),t._v(" "),_("li",[t._v("不要使用@import")]),t._v(" "),_("li",[t._v("避免过分重排")]),t._v(" "),_("li",[t._v("依赖继承")]),t._v(" "),_("li",[t._v("值缩写")]),t._v(" "),_("li",[t._v("避免好性能的属性")]),t._v(" "),_("li",[t._v("背景图优化合并")]),t._v(" "),_("li",[t._v("文件压缩")])]),t._v(" "),_("h3",{attrs:{id:"reflow-和-repaint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reflow-和-repaint"}},[t._v("#")]),t._v(" Reflow 和 Repaint")]),t._v(" "),_("p",[t._v("reflow 是指"),_("strong",[t._v("文档的布局或结构发生改变时，重新计算和更新文档中各个元素的位置和大小。")])]),t._v(" "),_("p",[t._v("repaint 是指"),_("strong",[t._v("当应用程序需要更新屏幕上某个区域时，由程序员手动触发的重绘操作。")])]),t._v(" "),_("h3",{attrs:{id:"减少-reflow-和-repaint"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少-reflow-和-repaint"}},[t._v("#")]),t._v(" 减少 reflow 和 repaint")]),t._v(" "),_("p",[t._v("以下是一些可以减少 reflow 和 repaint 的方法：")]),t._v(" "),_("ol",[_("li",[t._v("避免在 document 上直接进行频繁的 DOM 操作，如果确实需要可以采用 off-document 的方式进行。")]),t._v(" "),_("li",[t._v("将 DOM 离线后修改，例如先把 DOM 给 display:none，然后你想怎么改就怎么改。")]),t._v(" "),_("li",[t._v("不要把 DOM 结点的属性值放在一个循环里当成循环里的变量，不然这会导致大量地读写这个结点的属性。")]),t._v(" "),_("li",[t._v("尽可能的修改层级比较低的 DOM。")]),t._v(" "),_("li",[t._v("为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。")]),t._v(" "),_("li",[t._v("千万不要使用 table 布局，因为可能很小的一个小改动会造成整个 table 的重新布局。")]),t._v(" "),_("li",[t._v("不要一项一项的修改样式，尽量一次性写完。")]),t._v(" "),_("li",[t._v("当大量读写操作无法避免时，可以使用文档碎片"),_("code",[t._v("documentFragment")]),t._v("来解决。")]),t._v(" "),_("li",[t._v("使用 fixed 和 absolute 能够有效减少回流")])]),t._v(" "),_("h3",{attrs:{id:"fixed-和-absolute-能够减少回流的原因"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#fixed-和-absolute-能够减少回流的原因"}},[t._v("#")]),t._v(" Fixed 和 Absolute 能够减少回流的原因")]),t._v(" "),_("p",[t._v("fixed 和 absolute 可以减少回流的原因是，"),_("strong",[t._v("它们的位置是相对于文档的，而不是相对于文档中的其他元素")]),t._v("。因此，当使用 fixed 或 absolute 定位时，如果文档中的其他元素的位置或大小发生更改，它们的位置不会受到影响，因此不需要进行回流。")]),t._v(" "),_("p",[t._v("相比之下，如果使用相对定位（relative）或默认的 static 定位，当文档中的其他元素发生位置或大小的更改时，它们的位置也会随之更改，因此需要进行回流。回流会导致性能问题，因为它们会导致屏幕刷新的次数增加，从而影响应用程序的性能。")]),t._v(" "),_("p",[t._v("因此，使用 fixed 或 absolute 定位可以减少回流，从而提高应用程序的性能。")])])}),[],!1,null,null,null);v.default=i.exports}}]);