(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{702:function(n,e,t){"use strict";t.r(e);var i=t(10),l=Object(i.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"最小生成树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最小生成树"}},[n._v("#")]),n._v(" 最小生成树")]),n._v(" "),t("p",[n._v("如何计算图的最小生成树呢？")]),n._v(" "),t("p",[n._v("有两种算法")]),n._v(" "),t("ul",[t("li",[n._v("普利姆算法 （加点法）")]),n._v(" "),t("li",[n._v("克鲁斯卡尔算法 （加边法）")])]),n._v(" "),t("h3",{attrs:{id:"普利姆算法-加点法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普利姆算法-加点法"}},[n._v("#")]),n._v(" 普利姆算法（加点法）")]),n._v(" "),t("p",[n._v("特点")]),n._v(" "),t("p",[n._v("1、任选一个点作为起点")]),n._v(" "),t("p",[n._v("2、找到以当前选中点为起点路径最短的边")]),n._v(" "),t("p",[n._v("3、如果这个边的另一端没有被连通进来，那么就连接")]),n._v(" "),t("p",[n._v("4、如果这个边的另一端早就被连接进来，那么看倒数第二短的边")]),n._v(" "),t("p",[n._v("5、重复 2-4 过程，直到所有的点都连通为止。")]),n._v(" "),t("p",[t("img",{attrs:{src:"/Problem/picture/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%9B%BE.png",alt:"最小生成树图"}})]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('/**\n * 普利姆算法\n */\n /*\n 图节点\n function PNode(value){\n \t\tthis.value = value;\n \t\tthis.neighbor = [];\n }\n */\nconst { PNode } = require("./utils");\nvar max = Infinity;\nvar A = new PNode("A");\nvar B = new PNode("B");\nvar C = new PNode("C");\nvar D = new PNode("D");\nvar E = new PNode("E");\nvar pointSet = [A, B, C, D, E];\nvar distance = [\n  [0, 5, 4, 6, max],\n  [5, 0, 8, 7, max],\n  [4, 8, 0, max, max],\n  [6, 7, max, 0, 6],\n  [max, max, max, 6, 0],\n];\nfunction getIndex(target, pointSet) {\n  for (let i = 0; i < pointSet.length; i++) {\n    if (pointSet[i].value == target.value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction getMinDistance(pointSet, distance, nowPointSet) {\n  let fromNode = null;\n  let endNode = null;\n  let MinDistan = max;\n  for (let i = 0; i < nowPointSet.length; i++) {\n    let nowPointIndex = getIndex(nowPointSet[i], pointSet);\n    for (let j = 0; j < distance[nowPointIndex].length; j++) {\n      let thisNode = pointSet[j];\n      if (\n        nowPointSet.indexOf(thisNode) == -1 &&\n        distance[nowPointIndex][j] < MinDistan\n      ) {\n        fromNode = nowPointSet[i];\n        endNode = thisNode;\n        MinDistan = distance[nowPointIndex][j];\n      }\n    }\n  }\n  fromNode.neighbor.push(endNode);\n  endNode.neighbor.push(fromNode);\n  return endNode;\n}\n\nfunction prim(pointSet, distance, start) {\n  let allPointList = [];\n  allPointList.push(start);\n  while (true) {\n    let minDistanceNode = getMinDistance(pointSet, distance, allPointList);\n    allPointList.push(minDistanceNode);\n    if (allPointList.length === pointSet.length) {\n      break;\n    }\n  }\n  return allPointList;\n}\n\nconsole.log(prim(pointSet, distance, A))\n\n')])])]),t("h3",{attrs:{id:"克鲁斯卡尔算法-加边法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#克鲁斯卡尔算法-加边法"}},[n._v("#")]),n._v(" 克鲁斯卡尔算法（加边法）")]),n._v(" "),t("p",[n._v("特点")]),n._v(" "),t("p",[n._v("1、找到最短的边以这条边为起点。")]),n._v(" "),t("p",[n._v("2、要保证边连接的两端至少有一个点是新的点。")]),n._v(" "),t("p",[n._v("3、或者 这个边是将两个部落进行连接的。")]),n._v(" "),t("p",[n._v("4、重复 1-3 直到所有的点都连接到一起。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nfunction Node(value) {\n    this.value = value;\n    this.neighbor = []\n}\n\nlet m = Infinity\nlet distance = [\n    [0, 4, 7, 6, m],\n    [4, 0, m, m, m],\n    [7, m, 0, 8, 10],\n    [6, m, 8, 0, m],\n    [m, m, 10, m, 0],\n]\n\nlet A = new Node('A')\nlet B = new Node('B')\nlet C = new Node('C')\nlet D = new Node('D')\nlet E = new Node('E')\nlet pointSet = [A, B, C, D, E]\n\nfunction getIndex(allPointSet, target) {\n    for (let i = 0; i < allPointSet.length; i++) {\n        if (allPointSet[i].value == target.value) {\n            return i\n        }\n    }\n    return -1\n}\n\nfunction canLink(allPointSet, temp_begin, temp_end) {\n    let beginIn = null;\n    let beginEnd = null;\n    for (let i = 0; i < allPointSet.length; i++) {\n        if (getIndex(allPointSet[i], temp_begin) > -1) {\n            beginIn = allPointSet[i]\n        }\n        if (getIndex(allPointSet[i], temp_end) > -1) {\n            beginEnd = allPointSet[i]\n        }\n    }\n\n    if (beginIn && beginEnd && beginIn == beginEnd) {\n        return false\n    }\n    return true\n}\n\nfunction link(allPointSet, begin, end) {\n    let beginIn = null;\n    let beginEnd = null;\n    for (let i = 0; i < allPointSet.length; i++) {\n        if (getIndex(allPointSet[i], begin) > -1) {\n            beginIn = allPointSet[i]\n        }\n        if (getIndex(allPointSet[i], end) > -1) {\n            beginEnd = allPointSet[i]\n        }\n    }\n\n    if (!beginIn && !beginEnd) {\n        allPointSet.push([begin, end])\n    } else if (!beginIn && beginEnd) {\n        beginEnd.push(begin)\n    } else if (!beginEnd && beginIn) {\n        beginIn.push(end)\n    } else if (beginIn && beginEnd && beginIn != beginEnd) {\n        beginIn.concat(beginEnd)\n        allPointSet.splice(allPointSet.indexOf(beginEnd), 1)\n    }\n}\n\nfunction kruskal(pointSet, distance) {\n    let allPointSet = []\n    while (true) {\n        let begin = null\n        let end = null\n        let minDis = m\n        for (let i = 0; i < distance.length; i++) {\n            for (let j = 0; j < distance[i].length; j++) {\n                let temp_begin = pointSet[i]\n                let temp_end = pointSet[j]\n                let num = distance[i][j]\n                if (i != j && num < minDis && canLink(allPointSet, temp_begin, temp_end)) {\n                    begin = temp_begin\n                    end = temp_end\n                    minDis = distance[i][j]\n                }\n            }\n        }\n        begin.neighbor.push(end)\n        end.neighbor.push(begin)\n        link(allPointSet, begin, end)\n        if (allPointSet.length == 1 && allPointSet[0].length == pointSet.length) {\n            break\n        }\n    }\n    return allPointSet[0]\n}\n\nconsole.log(kruskal(pointSet, distance));\n")])])]),t("p",[n._v("添加注释并优化循环次数：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function getIndex(allPointSet, target) {\n    for (let i = 0; i < allPointSet.length; i++) {\n        if (allPointSet[i].value == target.value) {\n            return i\n        }\n    }\n    return -1\n}\n\nfunction midWare(allPointSet, temp_begin, temp_end) { // 中间处理函数，拿到节点对应的部落，起点对应的部落 与 终点对应的部落\n    let beginIn = null;\n    let beginEnd = null;\n    for (let i = 0; i < allPointSet.length; i++) {\n        if (getIndex(allPointSet[i], temp_begin) > -1) {\n            beginIn = allPointSet[i]\n        }\n        if (getIndex(allPointSet[i], temp_end) > -1) {\n            beginEnd = allPointSet[i]\n        }\n    }\n    return [beginIn, beginEnd] // 找到 节点对应的部落\n}\n\nfunction canLink(beginIn, beginEnd) {\n    if (beginIn && beginEnd && beginIn == beginEnd) { // 如果 beginIn 与 beginEnd 相等，则部落相等，那么同一个部落一定是已经相连过的点 返回 false\n        return false\n    }\n    return true\n}\n\nfunction link(allPointSet, beginIn, beginEnd, begin, end) {\n    if (!beginIn && !beginEnd) { // 都没有部落，则新增一个部落\n        allPointSet.push([begin, end])\n    } else if (!beginIn && beginEnd) { // 起点没有部落， 终点存在部落，意味着终点的部落要新增一个成员 -- 起点\n        beginEnd.push(begin)\n    } else if (!beginEnd && beginIn) { // 终点没有部落，起点存在部落，意味着起点的部落要新增一个成员 -- 终点\n        beginIn.push(end)\n    } else if (beginIn && beginEnd && beginIn != beginEnd) { // 两点都存在部落，但是部落是不同的，那么就连同两个部落，为一个大部落\n        beginIn.concat(beginEnd)\n        allPointSet.splice(allPointSet.indexOf(beginEnd), 1)\n    }\n}\n\nfunction kruskal(pointSet, distance) {\n    let allPointSet = []\n    while (true) {\n        let begin = null\n        let end = null\n        let minDis = m\n        let mid_begin = null\n        let mid_end = null\n        for (let i = 0; i < distance.length; i++) {\n            for (let j = 0; j < i; j++) { // 为什么是 i 次 因为 我们的 distance 关系表 中斜线对称，只需要遍历一边就可以了\n                if (i != j && distance[i][j] < minDis) {\n                    let temp_begin = pointSet[i]\n                    let temp_end = pointSet[j]\n                    let mid = midWare(allPointSet, temp_begin, temp_end)\n                    if (canLink(mid[0], mid[1])) {\n                        begin = temp_begin\n                        end = temp_end\n                        minDis = distance[i][j]\n                        mid_begin = mid[0]\n                        mid_end = mid[1]\n                    }\n\n                }\n            }\n        }\n        begin.neighbor.push(end)\n        end.neighbor.push(begin)\n        link(allPointSet, mid_begin, mid_end, begin, end)\n        if (allPointSet.length == 1 && allPointSet[0].length == pointSet.length) {\n            break\n        }\n    }\n    return allPointSet[0]\n}\n\nconsole.log(kruskal(pointSet, distance));\n")])])])])}),[],!1,null,null,null);e.default=l.exports}}]);