(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{723:function(r,n,a){"use strict";a.r(n);var t=a(10),e=Object(t.a)({},(function(){var r=this,n=r.$createElement,a=r._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h3",{attrs:{id:"排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序"}},[r._v("#")]),r._v(" 排序")]),r._v(" "),a("p",[r._v("首先我们要了解排序的本质，什么是排序呢？")]),r._v(" "),a("p",[r._v("给你一个数组 你会用什么样的方式对内部元素进行排序呢？")]),r._v(" "),a("p",[r._v("我们忘记创建代替数组，通过删除数组内部元素来排序的方式，因为这代表着你有更大的空间消耗，而且还删除了数组内部元素，性能可以说极差。")]),r._v(" "),a("p",[r._v("记住，排序不是比较大小。")]),r._v(" "),a("p",[r._v("排序是比较和交换的过程。")]),r._v(" "),a("p",[a("strong",[r._v("冒泡排序：")])]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function compare(a, b) {\n  return a > b;\n}\n\nfunction exchange(array, a, b) {\n  let temp = array[a];\n  array[a] = array[b];\n  array[b] = temp;\n}\n\nfunction sort(array) {\n  for (let i = 0; i < array.length - 1; i++) {\n    for (let j = 0; j < array.length - i - 1; j++) {\n      if (compare(array[j], arr[j + 1])) {\n        exchange(array, j, j + 1);\n      }\n    }\n  }\n}\n")])])]),a("p",[r._v("冒泡排序的本质呢，就是每次都会将两者之中最大的置于后面，这样当每一层循环结束，能够保证，最后面那个一定是最大的（或最小的，根据 compare中的定义来判断）")]),r._v(" "),a("p",[a("strong",[r._v("每次都会交换一个两者之中的最大值（或最小值）放在后面")])]),r._v(" "),a("p",[r._v("接下来我们看选择排序》")]),r._v(" "),a("p",[a("strong",[r._v("选择排序")])]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function compare(a, b) {\n  return a < b;\n}\n\nfunction exchange(array, a, b) {\n  let temp = array[a];\n  array[a] = array[b];\n  array[b] = temp;\n}\n\n// 选择排序\nfunction sort(array) {\n  for (let i = 0; i < array.length - 1; i++) {\n    let maxIndex = 0;\n    for (let j = 0; j < array.length - 1 - i; j++) {\n      if (compare(array[maxIndex], array[j + 1])) {\n        maxIndex = j + 1;\n      }\n    }\n    exchange(array, maxIndex, array.length - i - 1);\n  }\n}\n")])])]),a("p",[r._v("我们看下选择排序的原理，他呢和冒泡排序机器相似，但是有一个地方不同")]),r._v(" "),a("p",[r._v("我们冒泡排序的时候，每次比较都会进行元素置换，但是选择排序是取最大的（或最小的）那个元素和最后一个元素进行置换。从而达到排序的目的。")]),r._v(" "),a("p",[a("strong",[r._v("快速排序：")])]),r._v(" "),a("p",[r._v("快速排序呢比较不好理解，希望能多看几遍然后自行推导一下，如果感兴趣的话可以去看一下《算法导论》讲述了 算法推导的全过程。")]),r._v(" "),a("p",[r._v("首先我们先来看一下快排的工作原理：")]),r._v(" "),a("p",[r._v("![截屏2022-04-03 下午11.06.39](/Users/lucasy/workspace/new_level/note/Problem/picture/截屏2022-04-03 下午11.06.39.png)")]),r._v(" "),a("p",[r._v("可以先看下图，不知道画的清不清楚，")]),r._v(" "),a("p",[r._v("首先呢，我们拿到原数组之后第一次排序，我们先拿到一个对照点，比如取数组第一个元素， 然后呢和数组中其他元素进行比对，比这个点小的 就站在 对照点的左边，比对照点大的，就站在对照点的右边。")]),r._v(" "),a("p",[r._v("理论如此，我们上代码")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function quickSort(arr) {\n  if (!arr || arr.length < 1) return [];\n\n  var left = [];\n  var right = [];\n  var current = arr[0];\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] < current) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n  left = quickSort(left);\n  right = quickSort(right);\n\n  return left.concat([current], right);\n}\n")])])]),a("p",[r._v("首先呢，我们看下 核心部分，使用一个循环来对比元素的大小。将比对照点大的放到 right 数组，然后将比对照点小的放到 left 数组中。但是这样不够，为什么不够呢")]),r._v(" "),a("p",[r._v("这只进行了一次排序然后将大小分组对吧")]),r._v(" "),a("p",[r._v("没错，然后重点来了，看到下面这里")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("  left = quickSort(left);\n  right = quickSort(right);\n")])])]),a("p",[r._v("我们继续递归来排序，各自的数组，想象一下，当你走到最后一个的时候，left、right 都是空数组了，空数组走到严谨性判断直接返回也就不会继续走这两行代码。于是递归结束。懂了？")]),r._v(" "),a("p",[r._v("上面这个呢是简化版本的快速排序，可以发现创建了很多辅助数组，牺牲了额外的内存空间来完成排序，也是可以的")]),r._v(" "),a("p",[r._v("接下来我们看下标准的快速排序。")]),r._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[r._v("function exchange(arr, a, b) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\n\nfunction quickSort(arr, begin, end) {\n  if (begin >= end - 1) return;\n  let left = begin;\n  let right = end;\n  do {\n    do left++;\n    while (left < right && arr[left] < arr[begin]);\n    do right--;\n    while (right > left && arr[right] > arr[begin]);\n    if (left < right) exchange(arr, left, right);\n  } while (left < right);\n  let current = left == right ? right - 1 : right;\n  exchange(arr, begin, current);\n  quickSort(arr, begin, current);\n  quickSort(arr, current + 1, end);\n}\n\nfunction main(arr) {\n  quickSort(arr, 0, arr.length);\n}\n")])])]),a("p",[r._v("思想是相同的，只不过没有了额外的辅助数组")]),r._v(" "),a("p",[r._v("多多练习")])])}),[],!1,null,null,null);n.default=e.exports}}]);