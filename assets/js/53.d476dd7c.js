(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{642:function(a,n,e){"use strict";e.r(n);var o=e(7),t=Object(o.a)({},(function(){var a=this,n=a.$createElement,e=a._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"提升"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提升"}},[a._v("#")]),a._v(" 提升")]),a._v(" "),e("p",[a._v("我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。")]),a._v(" "),e("p",[a._v("这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。\n可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的\n最顶端，这个过程被称为提升。")]),a._v(" "),e("p",[a._v("如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('    "use strict"\n    a = 2;\n    console.log(a);\n    var a;\n')])])]),e("p",[a._v("上述代码会输出什么？\n因为是严格模式，所以并不会在全局作用域声明同名变量，有的开发者会认为 Reference Error，但实际上输出 2")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    console.log(a)\n    var a = 2;\n")])])]),e("p",[a._v("这个又输出什么呢？\n应该是 "),e("em",[a._v("undefined")])]),a._v(" "),e("p",[a._v("大概的原理就是，编译器会将 声明和赋值 分开处理。\n用 var a = 10; 举例\n它会被拆分成 var a; a = 10; 然后 先进性 var a 也就是声明变量 a 此时 a 为 undefined，表示作用域中已经存在这个变量了，然后当读到前面的 var a = 10; 这行代码时，在进行剩下的赋值操作。")]),a._v(" "),e("p",[e("strong",[a._v("先有声明，然后赋值")])]),a._v(" "),e("p",[a._v("只有声明本身会被提升，而赋值或其他运行逻辑会留在 原地 。如果提升改变了代码执行的顺序，会造成非常严重的破坏。")]),a._v(" "),e("p",[a._v("函数声明也会被提升")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  foo()\n  \n  function foo(){\n    console.log(1);\n  }\n")])])]),e("p",[a._v("但是请注意！！！ 函数表达式不会被提升！")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  foo();\n  var foo = function (){\n    console.log(1)\n  }\n")])])]),e("p",[a._v("为什么呢？\n我们 var 声明的变量的初始值是 undefined，函数声明的值是 function(){}\n也就是说 当 foo 执行的时候 foo 为 undefined 我们对 undefined() 调用。 TypeError。他会告诉你 foo 不是 function")]),a._v(" "),e("p",[a._v("如果 var 声明 和 函数声明 声明的是同一个会发生什么？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(foo);\n\nvar foo;\nfunction foo() {\n    console.log(2);\n}\n")])])]),e("p",[a._v("我们发现打印结果是 foo 函数，调换他们的位置,发现结果是相同的。\n"),e("strong",[a._v("函数声明和变量声明都会被提升。 函数会首先被提升，然后才是变量。")])]),a._v(" "),e("p",[a._v("在看下面")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function foo() {\n    console.log(2);\n}\n\nvar foo;\nconsole.log(foo);\n")])])]),e("p",[a._v("如果只是在函数后声明了变量，但没有赋值，foo 还是函数。")])])}),[],!1,null,null,null);n.default=t.exports}}]);