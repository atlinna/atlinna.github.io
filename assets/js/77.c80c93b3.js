(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{666:function(t,o,n){"use strict";n.r(o);var e=n(10),r=Object(e.a)({},(function(){var t=this,o=t.$createElement,n=t._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"原型和原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链"}},[t._v("#")]),t._v(" 原型和原型链")]),t._v(" "),n("hr"),t._v(" "),n("h4",{attrs:{id:"构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),n("h5",{attrs:{id:"什么是构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是构造函数"}},[t._v("#")]),t._v(" 什么是构造函数")]),t._v(" "),n("p",[t._v("constructor 返回创建实例对象时构造函数的引用。此属性的值是对函数的本身的引用，而不是一个包含函数名称的字符串。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\np = new Person('zhang san', 18)\nconsole.log(p.constructor === Person); // true\nconsole.log(p.constructor === Object); // false\n")])])]),n("p",[t._v("构造函数本身就是一个函数，和普通函数没有任何区别，不过为了规范一般将首字母大写。\n构造函数和普通函数的区别在于：使用new 生成实例的函数就是构造函数，直接调用的就是普通函数。\n那这样是不是意味着普通的函数创建的实例没有 constructor 属性呢？ 不一定。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function score() {\n    return {\n        name: 'lisi'\n    }\n}\n\nvar s = score()\nconsole.log(s.constructor === Object);\n")])])]),n("h4",{attrs:{id:"symbol-是构造函数吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symbol-是构造函数吗"}},[t._v("#")]),t._v(" Symbol 是构造函数吗")]),t._v(" "),n("p",[t._v("Symbol 是基本数据类型，但是作为构造函数来说它并不完整，因为它不支持语法new Symbol(),Chrome 认为其不是构造函数，如果要生成实例直接使用 Symbol（）即可。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(new Symbol(123)); // Symbol is not a constructor\nconsole.log(Symbol(123)); // Symbol(123)\n")])])]),n("p",[t._v("虽然 Symbol是基本数据类型，但是Symbol(123)实例可以获取constructor属性值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var s = Symbol(123)\nconsole.log(s.constructor); // f Symbol(){ [native code] }\n")])])]),n("p",[t._v("这里的 constructor 属性来自哪里？ 其实是 Symbol 原型上的，即Symbol.prototype.constructor 返回创建实例原型的函数，默认为 Symbol 函数。")]),t._v(" "),n("h4",{attrs:{id:"constructor值只读吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#constructor值只读吗"}},[t._v("#")]),t._v(" constructor值只读吗")]),t._v(" "),n("p",[t._v("这个要分情况来看的，对于引用类型来讲 constructor 属性值是可以修改的，但是对u基本类型来说是只读的。\n引用类型中constructor值可以修改，比如在原型链继承方案中，需要对constructor重新赋值进行修改。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype = {\n    method: function () { }\n};\n\nfunction Teacher() {\n}\n\nTeacher.prototype = new Person('zhang san', 19)\nTeacher.prototype.fs = 'Hello Person';\n\nconsole.log(Teacher.prototype.constructor === Object); // true\n\nTeacher.prototype.constructor = Person;\n\nconsole.log(Teacher.prototype); // {name: \"zhang san\", age: 19, fs: \"Hello Person\", constructor: ƒ}\nvar t = new Teacher('zhang san', 10)\nconsole.log(t); // Teacher {}\nconsole.log(t.name); // zhang san\nconsole.log(t.age); // 19\n")])])]),n("p",[t._v("对于基本类型来说 constructor 是只读的 如 1、‘hello world’、true、Symbol 当然 null 和 undefined 是没有 constructor 属性的。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function Type() { };\nvar\ttypes = [1, "hello world", true, Symbol(11)];\n\nfor(var i = 0; i < types.length; i++) {\n\ttypes[i].constructor = Type;\n\ttypes[i] = [ types[i].constructor, types[i] instanceof Type, types[i].toString() ];\n};\n\nconsole.log( types.join("\\n") );\n// function Number() { [native code] }, false, 1\n// function String() { [native code] }, false, muyiy\n// function Boolean() { [native code] }, false, true\n// function Symbol() { [native code] }, false, Symbol(123)\n')])])]),n("p",[t._v("为什么呢？ 因为创建他们的是只读的原生构造函数(native constructors), 这个例子也说明了依赖一个对象的 constructor 属性并不安全。")]),t._v(" "),n("h4",{attrs:{id:"模拟new的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模拟new的实现"}},[t._v("#")]),t._v(" 模拟new的实现")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function myNEW() {\n    // 1、创建一个空对象\n    var obj = Object.create(null)\n    // 2、拿到我们的构造函数并删除arguments中的第一项\n    var handler = Array.prototype.shift.call(arguments)\n    // 3、链接到原型，obj可以访问构造函数原型中的属性\n    Object.setPrototypeOf(obj, handler.prototype)\n    // 4、绑定 this 实现继承，obj可以访问到构造函数中的属性\n    var ret = handler.apply(obj, arguments)\n    // 5、优先返回构造函数中的返回的对象\n    return ret instanceof Object ? ret : obj\n}\n\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nconsole.log(myNEW(Person, 'zhang san', 19));\nconsole.log(new Person('zhang san', 19));\n")])])]),n("h4",{attrs:{id:"prototype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prototype"}},[t._v("#")]),t._v(" prototype")]),t._v(" "),n("p",[t._v("Javascript 是一种基于原型的语言（prototype-based language），这个和 Java 等基于类的语言不同。")]),t._v(" "),n("p",[t._v("每个对象拥有一个"),n("strong",[t._v("原型对象")]),t._v("，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的 prototype 属性上，而非对象实例本身。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nvar person = new Person('zhang san', 18)\nconsole.dir(Person)\n\nconsole.log(Person.prototype.constructor === Person);\n\nconsole.log(Person.prototype);\n\n// 打印结果如下\n    ƒ Person(name, age)\n      arguments: null\n      caller: null\n      length: 2\n      name: \"Person\"\n      prototype:\n          constructor: ƒ Person(name, age)\n          __proto__: Object\n      __proto__: ƒ ()\n\n// 2\n    {constructor: ƒ}\n      constructor: ƒ Person(name, age)\n      __proto__: Object\n      \n// 3\n    true\n")])])]),n("p",[t._v("我们写了一个构造函数，然后通过 console.dir 打印出了 Person\n通过执行结果 我们可以看到 构造函数Person 有一个原型对象 prototype， 其上有两个属性，分别是 constructor 和 "),n("strong",[t._v("proto")])]),t._v(" "),n("p",[t._v("构造函数Person 有一个指向原型的指针（Person.prototype），原型 Person.prototype 有一个指向构造函数的指针，通过上面的代码我们会发现，这是一个循环引用。")]),t._v(" "),n("h4",{attrs:{id:"proto"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#proto"}},[t._v("#")]),t._v(" "),n("strong",[t._v("proto")])]),t._v(" "),n("p",[t._v("上面代码可以看到 Person 原型(Person.prototype) 上有 "),n("strong",[t._v("proto")]),t._v(" 属性， 这个是一个访问器属性(即 getter 函数 和 setter 函数),\n通过它可以访问到对象的内部[[Prototype]]   这个[[Prototype]]可以是一个对象 也可能是 null。  对象 或 null。")]),t._v(" "),n("p",[n("strong",[t._v("proto")]),t._v(" 发音 (dunder proto),最先被 Firefox 使用，后来在 ES6 被列为 Javascript 的标准内建属性。")]),t._v(" "),n("p",[t._v("[[Prototype]] 是对象的一个内部属性，外部代码无法直接访问。 --》 遵循 ECMAScript 标准，someObject.[[Prototype]] 符号用于指向 someObject 的原型。\n"),n("strong",[t._v("proto")]),t._v(" dunder proto 是每个实例上都会有的属性， 但是 prototype 是构造函数的属性， 这两个并不相同，但是他们指向同一个对象。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nvar person = new Person('zhang san', 18)\n\nconsole.log(person.__proto__ === Person.prototype); // true\n")])])]),n("p",[t._v("这里获取 person 的对象的原型 与 Person 的原型对象进行比较")]),t._v(" "),n("p",[n("strong",[t._v("那么 构造函数、实例对象、对象原型之间的关系：")]),n("br"),t._v("\n首先构造函数的 dunder proto（"),n("strong",[t._v("proto")]),t._v("）指向的是 对象原型 [CONSTRUCTOR -- 构造函数 ].prototype ,然后对象原型中有属性 constructor 指向构造函数，然后构造函数的 prototype 指向对象原型。\n由于工作环境无法上传图片 就给各位老板手绘一波关系图")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("                     .__proto__                                       .constructor\n    实例 person   ---------------- >    对象原型 Person.prototype   --------------------- >  构造函数 - Person \n                                                   ^                                                |\n                                                   |________________________________________________|\n                                                                       .prototype\n")])])]),n("p",[n("strong",[t._v("注意：")]),t._v(" "),n("strong",[t._v("proto")]),t._v(" 属性在 ES6 时才被标准化，以确保 Web 浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。为了更好的支持，推荐使用 Object.getPrototypeOf().")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    通过改变一个对象的 [[Prototype]] 属性来改变和继承属性会对性能造成非常严重的影响，并且性能消耗的时间也不是简单的花费在 obj.__proto__ = ... 语句上, 它还会影响到所有继承自该 [[Prototype]] 的对象，如果你关心性能，你就不应该修改一个对象的 [[Prototype]]。\n")])])]),n("p",[t._v("如果要读取或修改对象的 [[Prototype]] 属性，建议使用如下方案，但是此时设置对象的 [[Prototype]] 依旧是一个缓慢的操作，如果性能是一个问题，就要避免这种操作。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var obj = {\n    name: 'Person',\n    age: 18\n}\n\nvar teacher = {\n    type: 'teacher',\n    gender: 'man'\n}\n\nObject.setPrototypeOf(obj, teacher)\nconsole.log(obj);\nconsole.log(Object.getPrototypeOf(obj));\n")])])]),n("p",[t._v("如果要创建一个新对象，同时继承另一个对象的[[Prototype]],推荐使用 Object.create().")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var teacher = {\n    type: 'teacher',\n    gender: 'man'\n}\nvar s = Object.create(teacher)\nconsole.log(s);\n")])])]),n("p",[n("strong",[t._v("优化 new 的实现")]),n("br"),t._v("\n正如上面介绍的不建议使用 "),n("strong",[t._v("proto")]),t._v(" 修改原型，所以我们使用 Object.create() 来实现\n我们只需要把之前 链接原型 和创建空对象 放在一起进行 使对象直接继承我们构造函数的原型。\n如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tfunction myNEW() {\n\t    var handler = Array.prototype.shift.call(arguments);\n\t    var obj = Object.create(handler.prototype);\n\t    var ret = handler.apply(obj, arguments)\n\t    return ret instanceof Object ? ret : obj\n\t}\n")])])]),n("h4",{attrs:{id:"原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),n("p",[t._v("每个对象都拥有一个原型对象，通过 "),n("strong",[t._v("proto")]),t._v(" 指向上一个原型，并从中继承方法和属性， 同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链（prototype chain），\n通过原型链，一个对象会拥有定义在其他对象中的属性和方法。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name) {\n    this.name = name;\n}\n\nvar p = new Person('zhang san');\n\nconsole.log(p.constructor === Person); // true\n")])])]),n("p",[t._v("这段代码打印出的结果是 true 是意味着 实例中存在 constructor 属性指向构造函数吗？\n当然不是 我们之前打印除了 实例的结构 发现  实例 p 本身没有 constructor，是通过原型链向上查找 "),n("strong",[t._v("proto")]),t._v("，最终找到 constructor 属性，该属性指向 Person。\n于是 我们的原型链 如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name) {\n    this.name = name;\n}\n\nvar p = new Person('zhang san');\n\nconsole.log(p.__proto__ === Person.prototype);\nconsole.log(p.__proto__.__proto__ === Object.prototype);\nconsole.log(p.__proto__.__proto__.__proto__ === null);\n")])])]),n("p",[t._v("__proto__属性指向的是上一个原型，也就是说 我们一直在取上一个原型，只要我们的取出来的不是null （最顶层的原型）")]),t._v(" "),n("h4",{attrs:{id:"小结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("ul",[n("li",[t._v("Symbol 作为构造函数来说并不完整，因为不支持语法 new Symbol()，但其原型上拥有 constructor 属性，即 Symbol.prototype.constructor。")]),t._v(" "),n("li",[t._v("引用类型 constructor 属性值是可以修改的， 但是对于基本类型来说是只读的， null 和 undefined 没有 constructor 属性。")]),t._v(" "),n("li",[n("strong",[t._v("proto")]),t._v(" 是每个实例上都有的属性， prototype 是构造函数的属性，这两个并不一样，但 p."),n("strong",[t._v("proto")]),t._v(" 和 Person.prototype 指向同一个对象。")]),t._v(" "),n("li",[n("strong",[t._v("proto")]),t._v(" 属性在 ES6 时被标准化，但因为性能问题并不推荐使用，推荐使用Object.getPrototypeOf（）")]),t._v(" "),n("li",[t._v("每个对象拥有一个原型对象，通过 "),n("strong",[t._v("proto")]),t._v(" 指针指向上一个原型，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向null，这就是原型链。")])]),t._v(" "),n("hr"),t._v(" "),n("p",[n("strong",[t._v("注意：对象是通过 "),n("strong",[t._v("proto")]),t._v(" 指向上一个原型，并继承方法和属性")]),t._v("\n用到的是继承而不是复制")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.length = 101;\n\nvar p = new Person('zhang san');\nconsole.log(p.__proto__);\n")])])]),n("p",[t._v("我们会发现 结果中存在 length 属性。")]),t._v(" "),n("p",[n("strong",[t._v("原型上的属性和方法定义在 prototype 对象上，而非对象实例本身/当访问一个对象的属性/方法时,它不仅仅在该对象上查找，还会查找该对象的原型，以及该对象的原型的原型，一层一层往上找，\n直到找到一个名字匹配的属性/方法或者到达原型的最顶层 null 。")])]),t._v(" "),n("p",[t._v("思考如果调用 person.valueOf() 会发生什么？")]),t._v(" "),n("ul",[n("li",[t._v("首先会检查 person 对象上是否具有可用的 valueOf 方法。")]),t._v(" "),n("li",[t._v("如果没有，则会向上查找 person 对象的原型对象 (person."),n("strong",[t._v("proto")]),t._v(" 即 Person.prototype) 是否具有可用的 valueOf 方法。")]),t._v(" "),n("li",[t._v("如果没有，则继续向上查找 person 的原型对象的原型对象 (person."),n("strong",[t._v("proto")]),t._v("."),n("strong",[t._v("proto")]),t._v(" 即 Object.prototype) 看是否存在可用的 valueOf 方法。此时找到了 valueOf 方法执行")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person(name) {\n    this.name = name;\n}\n\n\nvar p = new Person('zhang san');\nconsole.log(p.valueOf(),p);\n")])])]),n("h4",{attrs:{id:"prototype-和-proto"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prototype-和-proto"}},[t._v("#")]),t._v(" prototype 和 "),n("strong",[t._v("proto")])]),t._v(" "),n("p",[t._v("区别：\n原型对象 prototype 是构造函数上的属性， "),n("strong",[t._v("proto")]),t._v(" 是每个实例上都有的属性，两个属性不同但是指向的是同一个对象。")]),t._v(" "),n("p",[t._v("那么原型链的构建是依赖于 prototype 还是 "),n("strong",[t._v("proto")]),t._v(" 呢？\n"),n("a",{attrs:{href:"https://camo.githubusercontent.com/20b790bd15137b6aa77ddc1ce17a60ed2a772d8807cc6886dd1e2185052d7d75/68747470733a2f2f322e62702e626c6f6773706f742e636f6d2f2d3269694c57367774454f302f55477444582d5a505f6f492f41414141414141414166512f46705346434567316b37512f73313630302f4a6176617363726970742b50726f746f747970616c2b496e6865726974616e63652b4469616772616d2b2d2b6772616e642b706963747572652b2833292e706e67",target:"_blank",rel:"noopener noreferrer"}},[t._v("如图"),n("OutboundLink")],1),t._v("\n如上图所示，我们会发现在原型链中 Foo.prototype 中的 prototype 并没有狗哼一条原型链，它只是指向了原型链中的某一处位置。 原型链的构建依赖于 "),n("strong",[t._v("proto")]),t._v("， 如上图中 foo."),n("strong",[t._v("proto")]),t._v(" 指向 Foo.prototype ， foo."),n("strong",[t._v("proto")]),t._v("."),n("strong",[t._v("proto")]),t._v(" 指向 Bichon.prototype 如此一层一层最终链接到 null 。")]),t._v(" "),n("p",[n("strong",[t._v("注意： 不要使用 Bar.prototype = Foo ,因为这不会执行 Foo 的原型，而是指向函数 Foo ，因此原型链将会链接到 Function.prototype 而不是 Foo.prototype ,因此 methods 方法不会再 Bar\n的原型链上。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Foo() {\n    return 'foo'\n}\n\nFoo.prototype.methods = function () {\n    return 'method'\n}\n\nfunction Bar() {\n    return 'bar'\n}\n\nBar.prototype = Foo\nlet bar = new Bar()\nconsole.log(bar);\n")])])]),n("h4",{attrs:{id:"instanceof-的原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-的原理"}},[t._v("#")]),t._v(" instanceOf 的原理")]),t._v(" "),n("p",[t._v("instanceOf 运算符用来检测 constructor.prototype 是否在参数的原型链上")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n\n}\n\nfunction People() {\n\n}\n\nvar p = new Person()\n\nconsole.log(p instanceof Person); // true   Object.getPrototypeOf(p) === Person.prototype\nconsole.log(p instanceof People); // false\nconsole.log(Object.getPrototypeOf(p) === Person.prototype);\n")])])]),n("p",[n("strong",[t._v("instanceOf原理就是:一层一层查找 "),n("strong",[t._v("proto")]),t._v("，如果和 constructor.prototype 相等 则返回 true ，如果一直没有查找成功则返回 false")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  instance.[__proto__...] === instance.constructor.prototype\n")])])]),n("p",[t._v("那么我们知道了原理就来浅试一下 实现 instanceOf：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function myInstanceOf(A, B) {\n    var target = B.prototype;\n    while (A.__proto__) {\n        if (A.__proto__ === target) {\n            return true;\n        }\n        A = A.__proto__;\n    }\n    return false;\n}\n\nfunction Person() {\n\n}\n\nfunction People() {\n\n}\n\nvar p = new Person();\n\nconsole.log(p instanceof Person); // true   Object.getPrototypeOf(p) === Person.prototype\nconsole.log(p instanceof People); // false\nconsole.log(Object.getPrototypeOf(p) === Person.prototype);\n\n\nconsole.log(myInstanceOf(p, Person));  // true\nconsole.log(myInstanceOf(p, People));  // false\n")])])]),n("h4",{attrs:{id:"原型链继承"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承"}},[t._v("#")]),t._v(" 原型链继承")]),t._v(" "),n("p",[t._v("原型链继承的本质就是重写原型对象，用一个新的要继承的实例来替代。 新的原型 Solder 不仅有 new Person() 实例上的全部属性和方法，并且由于指向了 Person 原型，所以还拥有 Person 原型上的所有方法和属性。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.name = 'zhang san';\n}\n\nPerson.prototype.run = function () {\n    console.log(this.name + ' is running!');\n}\n\nfunction Solder() {\n\n}\n\n\nSolder.prototype = new Person()\nvar s = new Solder()\nconsole.log(s);\ns.name = 'li si'\ns.run()\n")])])]),n("p",[t._v("原型链继承方案有以下缺点：")]),t._v(" "),n("ul",[n("li",[t._v("多个实例对引用类型的操作会被篡改")]),t._v(" "),n("li",[t._v("子类型的原型上的 constructor 属性被重写了")]),t._v(" "),n("li",[t._v("给子类型原型添加属性和方法必须在替换原型之后")]),t._v(" "),n("li",[t._v("创建子类型实例时无法向父类型的构造函数传参")])]),t._v(" "),n("p",[t._v("** 一**"),n("br"),t._v("\n我们先来看第一个\n在原型链继承方案中，我们的原型会变成另一个类型的实例，如下数代码， Solder.prototype 变成了 Person 的一个实例，所以 Person的实例属性 hobbies 就变成了 Solder 的属性。")]),t._v(" "),n("p",[t._v("在原型属性上的引用类型数据会被所有的实例共享，每个实例都能对其进行修改，所以多个实例对引用类型的操作会篡改原数据，如下 我们修改了 s1 实例中的实例属性后，影响到了 s2 中实例属性的值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.hobbies = ['football', 'basketball', 'swimming'];\n}\n\nPerson.prototype.run = function () {\n    console.log(this.name + ' is running!');\n}\n\nfunction Solder() {\n\n}\n\n\nSolder.prototype = new Person()\nvar s1 = new Solder()\nvar s2 = new Solder()\nconsole.log(s1.hobbies, s2.hobbies);\ns1.hobbies.shift()\nconsole.log(s1.hobbies, s2.hobbies);\n")])])]),n("p",[t._v("** 二**"),n("br"),t._v("\n首先看下面代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.hobbies = ['football', 'basketball', 'swimming'];\n}\n\nPerson.prototype.run = function () {\n    console.log(this.name + ' is running!');\n}\n\nfunction Solder() {\n\n}\n\n\nSolder.prototype = new Person()\nvar p = new Solder()\nconsole.log(p.constructor);\n\n/\n*ƒ Person() {\n    this.hobbies = ['football', 'basketball', 'swimming'];\n}\n*/\n")])])]),n("p",[t._v("观察打印结果 我们发现通过 new Solder() 出的实例的构造函数，不是 Solder 而是 Person\n因为这个 Solder 的 原型对象指向的是 Person 的实例 这个实例的构造函数 constructor 是 Person\n解决方法就是 重写 我们这个 Solder 的 constructor 让他指向 Solder")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.hobbies = ['football', 'basketball', 'swimming'];\n}\n\nPerson.prototype.run = function () {\n    console.log(this.name + ' is running!');\n}\n\nfunction Solder() {\n\n}\n\n\nSolder.prototype = new Person()\nSolder.prototype.constructor = Solder;  // 新增代码 将 Solder 原型对象的 constructor 指向自己的构造函数 Solder\nvar p = new Solder()\nconsole.log(p.constructor);\n/*\nƒ Solder() {\n\n}\n*/\n")])])]),n("p",[t._v("** 三**"),n("br"),t._v("\n给子类型原型添加属性和方法要在替换原型之后，因为我们会替换子类型的原型 替换之后指向了 Person 的 实例。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.hobbies = ['football', 'basketball', 'swimming'];\n}\n\nPerson.prototype.say = function () {\n    return this.hobbies.join(' ') // 修改方法\n}\n\nfunction Solder() {\n\n}\n\n\nSolder.prototype = new Person()\nSolder.prototype.constructor = Solder;\n\nSolder.prototype.say = function () {\n    return this.hobbies.join(','); // 新增方法\n}\n\nvar p = new Solder()\nconsole.log(p.say());\n")])])]),n("p",[t._v("我们会发现，现在实例能访问两个 say 方法 ，但是 实际上运行的是我们新增在 Solder 原型对象上的 say 方法 而 Person.prototype 上也有一个 say 方法，但是它不会访问到。这种情况称为 属性遮蔽。\n如果我们要访问 Person 上的 say 方法要如何操作？ 通过 "),n("strong",[t._v("proto")]),t._v("  // console.log(p."),n("strong",[t._v("proto")]),t._v("."),n("strong",[t._v("proto")]),t._v(".say);")]),t._v(" "),n("h4",{attrs:{id:"其他继承方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他继承方案"}},[t._v("#")]),t._v(" 其他继承方案")]),t._v(" "),n("p",[t._v("由于 ES6 封装了 class 日常工作中我们使用 ES6 Class Extends (模拟原型)继承方案即可，更多可阅读 木易杨大神的 "),n("a",{attrs:{href:"https://github.com/yygmind/blog/issues/7",target:"_blank",rel:"noopener noreferrer"}},[t._v("Javascript 8种继承方案"),n("OutboundLink")],1)]),t._v(" "),n("h4",{attrs:{id:"练习"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#练习"}},[t._v("#")]),t._v(" 练习：")]),t._v(" "),n("p",[t._v("有三个判断数组的方法，请分别介绍他们之间的区别和优劣")]),t._v(" "),n("ul",[n("li",[t._v("Object.prototype.toString.call()")]),t._v(" "),n("li",[t._v("instanceOf")]),t._v(" "),n("li",[t._v("Array.isArray()")])]),t._v(" "),n("h4",{attrs:{id:"小结-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#小结-2"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),n("ul",[n("li",[t._v("每个对象拥有一个原型对象，通过 "),n("strong",[t._v("proto")]),t._v(" 指向上一个原型，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null，这种关系被称为 "),n("strong",[t._v("原型链")])]),t._v(" "),n("li",[t._v("当访问一个对象的属性或方法时，它不止在对象本身查找，还会查找该对象的原型，如果对象的原型也有原型，还会再该对象的原型的原型，一层一层，向上查找，直到找到名称完全匹配的属性或方法，或到达原型链的顶层 null 。")]),t._v(" "),n("li",[t._v("原型链的构建依赖于 "),n("strong",[t._v("proto")]),t._v(",一层一层最终链接到null。")]),t._v(" "),n("li",[t._v("instanceOf 的原理就是一层一层查找 "),n("strong",[t._v("proto")]),t._v("，如果和 constructor.prototype 相等则返回 true ，如果一直没有查找成功，则返回 false")]),t._v(" "),n("li",[t._v("原型链继承的本质就是重写原型对象，用一个新类型的实例来代替。")])]),t._v(" "),n("h3",{attrs:{id:"深入探究-function-object-鸡蛋问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#深入探究-function-object-鸡蛋问题"}},[t._v("#")]),t._v(" 深入探究 Function & Object 鸡蛋问题")]),t._v(" "),n("p",[t._v("上一部分在介绍原型链继承的过程中，给大家描述了原型链运作机制以及属性遮蔽等知识，这一节我们就来探究下 Function."),n("strong",[t._v("proto")]),t._v("  === Function.prototype 引起的鸡生蛋，蛋生鸡问题，并在这个过程中深入了解 Object.prototype、Function.prototype、function Object、function Function 之间的关系。")]),t._v(" "),n("p",[t._v("我们可以先来看看 ECMAScript 上的定义。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tThe value of the [[Prototype]] internal property of the Object prototype object is null, the value of the [[Class]] internal property is "Object", and the initial value of the [[Extensible]] internal property is true.\n\t\n\tObject原型对象的【[Prototype】]内部属性的值为null,[[Class]]内部属性的值为"Object",[[可扩展]]内部属性的初始值为true。\n')])])]),n("p",[t._v("Object.prototype 表示 Object 的原型对象，其 [[Prototype]] 属性值是 null ，访问器属性 "),n("strong",[t._v("proto")]),t._v(" 暴露了一个对象的内部 [[Prototype]]。 Object.prototype 并不是通过 Object 函数创建的，为什么呢？ 看如下代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Person() {\n    this.val = 'person'\n}\n\nvar person1 = new Person();\nperson1.__proto__ = Person.prototype;\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("实例对象的 __proto__ 指向 构造函数的 prototype 即 person1.__proto___ = Person.prototype,但是 Object.prototype.__proto__ = null 所以 Object.prototype 并不是通过 Object 函数创建的，那他是如何生成的？ 其实 Object.prototype 是浏览器底层根据 ECMAScript 规范创造的一个对象。\nObject.prototype 就是原型链的顶端 （不考虑 null），所有对象纪恒了它的 toString 等方法和属性。\n")])])]),n("h4",{attrs:{id:"function-prototype"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-prototype"}},[t._v("#")]),t._v(" Function.prototype")]),t._v(" "),n("p",[t._v("首先来看下 ECMAScript 上的定义：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\tThe Function prototype object is itself a Function object (its [[Class]] is "Function").\n\n\tThe value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object.\n\n\tThe Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object.\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("Function.prototype 对象是一个函数（对象），其[[Prototype]] 内部属性值指向内建对象 Object.prototype. Function.prototype 对象自身没有 valueOf 属性，其从 Object.prototype 对象继承了 valueOf 属性。\n\nFunction.prototype 的 [[Class]] 属性是 Function，所以这是一个函数，但又不大一样。为什么这么说呢？因为我们直到只有函数才有 prototype 属性，但并不是所有函数都有这个属性，因为 Function.prototype 这个函数就没有。\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tconsole.log(Function.prototype) // f(){[native code]}\n\tconsole.log(Function.prototype.prototype);  // undefined\n")])])]),n("p",[t._v("为什么 会没有 prototype 呢？\nFunction.prototype 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 prototype 属性，不然 Function.prototype.prototype... 将无休无止并且没有意义。")]),t._v(" "),n("h4",{attrs:{id:"function-object"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-object"}},[t._v("#")]),t._v(" function Object")]),t._v(" "),n("p",[t._v("先来看 ECMAScript 的定义")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("\tThe value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object.\n")])])]),n("p",[t._v("Object 作为构造函数时，其 [[Prototype]] 内部属性值指向 Function.prototype, 即")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(" \tObject.__proto__ = Function.prototype\n")])])]),n("p",[t._v("使用 new Object() 创建新对象时，这个新对象的 [[Prototype]] 内部属性指向构造函数的 prototype 属性，即 Object.prototype 属性，对应 Object.prototype")]),t._v(" "),n("p",[t._v("也可以通过对象字面量等方式创建对象。")]),t._v(" "),n("ul",[n("li",[t._v("使用对象字面量创建的对象，其 [[Prototype]] 值是 Object.prototype。")]),t._v(" "),n("li",[t._v("使用数组字面量创建的对象，其 [[Prototype]] 值是 Array.prototype。")]),t._v(" "),n("li",[t._v("使用 function f(){} 函数创建的对象， 其 [[Prototype]] 值是 Function.prototype。")]),t._v(" "),n("li",[t._v("使用 new fun() 创建的对象，其中 fun 是由 Javascript 提供的内建构造器函数之一 (Object, Function, Array, Boolean, Date, Number, String 等等)，其 [[Prototype]] 值是 fun.prototype")]),t._v(" "),n("li",[t._v("使用其他 Javascript 构造器函数创建的对象，其 [[Prototype]] 值就是该构造器函数的 prototype 属性。")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 1 -- 对象字面量方式\nvar obj = { name: 'zhang san' }\nconsole.log(obj.__proto__ === Object.prototype); // true obj -- > Object.prototype --\x3e null\n\n\n// 2 -- 数组字面量方式\nvar arr = ['zhangsan', 'lisi', 'wangwu'];\nconsole.log(arr.__proto__ === Array.prototype); // true\nconsole.log(arr.__proto__.__proto__ === Object.prototype); // true  arr --\x3e Array.prototype --\x3e Object.prototype --\x3e null\n\n\n// 3 -- function f(){} 方式\nfunction f() {\n    return 's'\n}\nconsole.log(f.__proto__ === Function.prototype); // true\nconsole.log(f.__proto__.__proto__ === Object.prototype); // true f --\x3e Function.prototype --\x3e Object.prototype --\x3e null\n\n\n// 4 -- new Function() 方式\nvar fun = new Function()\nconsole.log(fun.__proto__ === Function.prototype); // true\nconsole.log(fun.__proto__.__proto__ === Object.prototype); // true fun --\x3e Function.prototype --\x3e Object.prototype --\x3e null\n\n\nvar ob = new Object() // ob --\x3e Object.prototype --\x3e null\n\n\n// 5 -- 其他构造器函数\nfunction Person() {\n    return {}\n}\nvar p = new Person()\nconsole.log(p.__proto__ === Person.prototype); // false\nconsole.log(p.__proto__ === Object.prototype); // true  p --\x3e Object.prototype --\x3e null\n")])])]),n("h4",{attrs:{id:"function-function"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-function"}},[t._v("#")]),t._v(" function Function")]),t._v(" "),n("p",[t._v("定义")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('The Function constructor is itself a Function object and its [[Class]] is "Function". The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object.\n')])])]),n("p",[t._v("Fcuntion 构造函数是一个函数对象，其 [[Class]] 属性是 Function。Function 的 [[Prototype]] 属性指向了 Function.prototype ,即")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Function.__proto__ === Function.prototype\n")])])]),n("p",[t._v("哦吼？ 是不是有点意思了。")]),t._v(" "),n("h4",{attrs:{id:"function-object-鸡蛋问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-object-鸡蛋问题"}},[t._v("#")]),t._v(" Function & Object 鸡蛋问题")]),t._v(" "),n("p",[t._v("ok 我们先看下面的代码")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Object instanceof Function  // true\nFunction instanceof Object  // true\n\nObject instanceof Object    // true\nFunction instanceof Function    // true\n")])])]),n("p",[t._v("Object 构造函数继承了 Function.prototype，同时 Function 构造函数继承了 Object.prototype。这里就产生了"),n("strong",[t._v("鸡和蛋")]),t._v("的问题。 为什么会出现这种问题，因为 Function.prototype 和 Function."),n("strong",[t._v("proto")]),t._v(" 都指向 Function.prototype。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("console.log(Object.__proto__ === Function.prototype); // true\nconsole.log(Object.__proto__.__proto__ === Object.prototype); // true\n\nconsole.log(Function.__proto__.__proto__ === Object.prototype); // true\nconsole.log(Function.__proto__ === Function.prototype); // true\n")])])]),n("p",[t._v("而对于 Function."),n("strong",[t._v("proto")]),t._v(" === Function.prototype 这一现象有两种解释，争论点就在于 Function 对象是不是由 Function 构造函数创建的一个实例？")]),t._v(" "),n("p",[n("strong",[t._v("解释1、YES:")]),t._v("\n根据 Javascript 中对实例的定义， a 是 b 的实例，即 a instanceof b 为 true，默认判断条件就是 b.prototype 在 a 的原型链上。而 Function instanceof Function 为 true，本质上即 Object.getPrototypeOf(Function) === Function.prototype, 符合定义")]),t._v(" "),n("p",[n("strong",[t._v("解释2、NO:")]),n("br"),t._v("\nFunction 是 built-in 的对象（内置对象），也就是说并不存在 Function 对象由 Function 构造函数创建，这样显然会造成"),n("strong",[t._v("鸡蛋问题")]),t._v("。实际上，当你直接写一个函数是（如 function f(){} 或 x => x),也不存在调用 Function 构造器，只有在显示调用 Function 构造器时 （如 new Function('x','return x')） 才有。")]),t._v(" "),n("p",[t._v("个人比较偏向第二种吧，现有 Function.prototype 然后有的 function Function (){}, 所以就不存在"),n("strong",[t._v("鸡蛋问题")]),t._v("，把 Function."),n("strong",[t._v("proto")]),t._v(" 指向 Function.prototype 是为了保证原型链的完整， 让 Function 可以获取定义在 Object.prototype 上的方法。")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://camo.githubusercontent.com/f6885e99add627deab51b5533d4ae52b0755d8b3d0d71b8e27533ccaa821f084/68747470733a2f2f7773322e73696e61696d672e636e2f6c617267652f303036744e6337396779316732336e3436757a6a616a33306836306c703076372e6a7067",target:"_blank",rel:"noopener noreferrer"}},[t._v("上图"),n("OutboundLink")],1)]),t._v(" "),n("h4",{attrs:{id:"内置类型构建过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#内置类型构建过程"}},[t._v("#")]),t._v(" 内置类型构建过程")]),t._v(" "),n("p",[t._v("Javascript 内置类型是浏览器内核自带的，浏览器底层对 Javascript 的实现基于 C/C++，那么浏览器在初始化 Javascript 环境时发生了什么？")]),t._v(" "),n("ul",[n("li",[t._v("用 C/C++ 构建内部数据结构创建一个 OP （Object.prototype）以及初始化其内部属性但不包括行为。")]),t._v(" "),n("li",[t._v("用 C/C++ 构建内部数据结构创建一个 FP （Function.prototype） 以及初始化其内部属性但不包括行为。")]),t._v(" "),n("li",[t._v("将 FP 的 [[Prototype]] 指向 OP。")]),t._v(" "),n("li",[t._v("用 C/C++ 构造内部数据结构创建各种内置引用类型。")]),t._v(" "),n("li",[t._v("将各个内置引用类型的 [[Prototype]] 指向 FP。")]),t._v(" "),n("li",[t._v("将 Function 的 prototype 指向 FP")]),t._v(" "),n("li",[t._v("将 Object 的 prototype 指向 OP")]),t._v(" "),n("li",[t._v("用 Function 实例化出 OP，FP，以及 Object 的行为并挂载。")]),t._v(" "),n("li",[t._v("实例化内置对象 Math 和 Global\n至此，所有内置类型构建完成。")])])])}),[],!1,null,null,null);o.default=r.exports}}]);