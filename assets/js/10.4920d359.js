(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{600:function(t,r,v){"use strict";v.r(r);var a=v(10),_=Object(a.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"arkts-装饰器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arkts-装饰器"}},[t._v("#")]),t._v(" ArkTs 装饰器")]),t._v(" "),v("p",[t._v("ArkTs 的装饰器分为状态管理装饰器与行为装饰器")]),t._v(" "),v("h3",{attrs:{id:"行为装饰器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#行为装饰器"}},[t._v("#")]),t._v(" 行为装饰器")]),t._v(" "),v("h4",{attrs:{id:"component"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#component"}},[t._v("#")]),t._v(" @Component")]),t._v(" "),v("p",[v("strong",[t._v("Component")]),t._v(" 修饰符可以将一个结构体 struct 标记为自定义的组件。")]),t._v(" "),v("h4",{attrs:{id:"entry"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#entry"}},[t._v("#")]),t._v(" @Entry")]),t._v(" "),v("p",[v("strong",[t._v("Entry")]),t._v(" 则是将一个组件标记为一个入口页面。")]),t._v(" "),v("p",[t._v("那么也就是说同一个组件节点树中"),v("strong",[t._v("不能同时存在2个或多个 Entry 标记")])]),t._v(" "),v("h4",{attrs:{id:"builder"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#builder"}},[t._v("#")]),t._v(" @Builder")]),t._v(" "),v("p",[t._v("Builder 修饰符就比较有意思了。")]),t._v(" "),v("p",[t._v("React 中使用的是 JSX 语法，他的优点就是可以通过函数抽离出"),v("strong",[t._v("当前页面中使用次数多，但并非公共的组件")]),t._v("。")]),t._v(" "),v("p",[t._v("Builder 修饰符的功能类似。你可以在这个 struct 中抽离你认为的使用频率多的组件。")]),t._v(" "),v("h3",{attrs:{id:"状态管理装饰器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态管理装饰器"}},[t._v("#")]),t._v(" 状态管理装饰器")]),t._v(" "),v("h4",{attrs:{id:"state"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#state"}},[t._v("#")]),t._v(" @State")]),t._v(" "),v("p",[t._v("state装饰器使用来声明一个响应式的变量，当我们操作这个变量时，视图也会相应进行改变。")]),t._v(" "),v("p",[t._v("与 Vue 的响应式变量类似。")]),t._v(" "),v("p",[t._v("我们声明的"),v("strong",[t._v("基本类型")]),t._v("的数据 如："),v("em",[t._v("string、number、boolean、null、undefined")]),t._v("。都是可以"),v("strong",[t._v("响应式改变")]),t._v("的")]),t._v(" "),v("p",[t._v("对于引用类型的数据，也是深度监听。")]),t._v(" "),v("p",[t._v("比如对象啊，数组啊。")]),t._v(" "),v("p",[t._v("对于对象类型，如果只学习使用过 Vue2 的同学们来讲可能有一些情况")]),t._v(" "),v("p",[t._v("-- 由于 Vue2 采用的是 getter,setter 的形式添加响应式的，对于一些在对象初始化时没有的属性是监听不到的，为此 Vue2 提供的解决方案是通过 $set 来为一个对象的属性添加响应式。")]),t._v(" "),v("p",[t._v("-- 相比较之下 Vue3 通过 Proxy 能够捕捉到对象的任何改变对象的操作。不再需要借助 $set 的帮助。")]),t._v(" "),v("p",[t._v("@State 的响应式声明也是如此。你可以进行任何你想要的操作，"),v("strong",[t._v("build-in")]),t._v(" 的行为已足够满足你的需求")]),t._v(" "),v("h4",{attrs:{id:"prop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#prop"}},[t._v("#")]),t._v(" @Prop")]),t._v(" "),v("p",[t._v("Prop 则是声明一个组件的属性，单向的数据流，当然你也可以在组件的内部进行修改，但是结果可能不会像你想象的那样顺利。")]),t._v(" "),v("p",[t._v("如果真的需要修改父组件的数据，请考虑更换其他修饰符")]),t._v(" "),v("h4",{attrs:{id:"link"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#link"}},[t._v("#")]),t._v(" @Link")]),t._v(" "),v("p",[t._v("Link 修饰符给我的感觉更像是一个 v-model ，一个父子组件双向数据绑定的一个桥梁。")]),t._v(" "),v("p",[t._v("你可以通过 Link 修饰符在子组件中修改父组件传入的数据，同时，父组件也能捕捉到子组件进行了修改，然后显示在页面中。")])])}),[],!1,null,null,null);r.default=_.exports}}]);