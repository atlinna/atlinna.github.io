(window.webpackJsonp=window.webpackJsonp||[]).push([[115],{704:function(t,a,s){"use strict";s.r(a);var r=s(10),l=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"call"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[t._v("#")]),t._v(" call")]),t._v(" "),s("h3",{attrs:{id:"描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#描述"}},[t._v("#")]),t._v(" 描述：")]),t._v(" "),s("p",[s("strong",[t._v("参数")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("thisArg\n"),s("strong",[t._v("可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。")])])]),t._v(" "),s("p",[t._v("call() 允许为不同的对象分配和调用属于一个对象的函数/方法。")]),t._v(" "),s("p",[t._v("call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。")]),t._v(" "),s("h3",{attrs:{id:"分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分析"}},[t._v("#")]),t._v(" 分析：")]),t._v(" "),s("p",[t._v("call 方法实现的难点在于，我们如何去改变一个函数中的 this 。\n是否还记得，在一个对象中，如果我们调用这个对象的函数，其中的 this 是什么？ 是不是调用者也就是这个对象？\n我们需要给传入的对象添加一个属性，这个属性指向我们函数本身，然后通过对象调用这个函数，完成 this 指向的改变。\n最后只需要删除这个属性。")]),t._v(" "),s("h3",{attrs:{id:"代码实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码实现"}},[t._v("#")]),t._v(" 代码实现：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("    function myCall(...args) {\n        if(thisArgs == null) return this()\n        thisArgs.handler = this;\n        let ret = thisArgs.handler(...args)\n        delete thisArgs.handler;\n        return ret\n    }\n\n    Function.prototype.myCall = myCall;\n")])])])])}),[],!1,null,null,null);a.default=l.exports}}]);