(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{624:function(n,t,a){"use strict";a.r(t);var e=a(7),i=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"盒模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#盒模型"}},[n._v("#")]),n._v(" 盒模型")]),n._v(" "),a("h3",{attrs:{id:"行级元素-inline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行级元素-inline"}},[n._v("#")]),n._v(" 行级元素 - inline")]),n._v(" "),a("ul",[a("li",[n._v("内容决定元素占的位置")]),n._v(" "),a("li",[n._v("不可以通过 css 改变宽高\nspan\\ strong \\ em\\ a\\ del")])]),n._v(" "),a("h3",{attrs:{id:"块级元素-block"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#块级元素-block"}},[n._v("#")]),n._v(" 块级元素 block")]),n._v(" "),a("ul",[a("li",[n._v("独占一行")]),n._v(" "),a("li",[n._v("可以通过 css 改变宽高\ndiv \\ p\\ ul \\ li \\ ol \\ form \\ address")])]),n._v(" "),a("h3",{attrs:{id:"行级块元素-inline-block"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行级块元素-inline-block"}},[n._v("#")]),n._v(" 行级块元素 inline-block")]),n._v(" "),a("ul",[a("li",[n._v("内容决定大小")]),n._v(" "),a("li",[n._v("可以通过 css 改变宽高\nimg")])]),n._v(" "),a("p",[n._v("凡是 inline、inline-block 类型 的标签都存在文字特性")]),n._v(" "),a("h3",{attrs:{id:"盒模型的计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#盒模型的计算"}},[n._v("#")]),n._v(" 盒模型的计算")]),n._v(" "),a("p",[n._v("border + padding + width")]),n._v(" "),a("h2",{attrs:{id:"margin-塌陷问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#margin-塌陷问题"}},[n._v("#")]),n._v(" margin 塌陷问题")]),n._v(" "),a("p",[n._v("假设我们现在有这样一个结构")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        div {\n            width: 100px;\n            height: 100px;\n        }\n\n        .parent {\n            background-color: #000;\n        }\n\n        .content {\n            width: 50px;\n            height: 50px;\n            background-color: #f00;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="parent">\n        <div class="content"></div>\n    </div>\n</body>\n\n</html>\n')])])]),a("p",[n._v("然后我们移动父子位置")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        div {\n            width: 100px;\n            height: 100px;\n        }\n\n        .parent {\n            background-color: #000;\n            margin-left: 100px;\n            margin-top: 100px;\n        }\n\n        .content {\n            width: 50px;\n            height: 50px;\n            background-color: #f00;\n            margin-left: 50px;\n            margin-top: 50px;\n        }\n    </style>\n")])])]),a("p",[n._v("我们发现 子盒子（content）的margin-top 并没有生效。父盒子确实带着子盒子动了。\n只有当我们的子盒子的 margin-top 大于父盒子的margin-top 的时候 子盒子的 margin-top 才生效。\n这个时候新的问题又出现了，父盒子又随着子盒子一起跑偏了。")]),n._v(" "),a("h3",{attrs:{id:"bfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[n._v("#")]),n._v(" BFC")]),n._v(" "),a("p",[n._v("Block Format Content（块级元素格式化文档流）\n如何触发一个盒子的 BFC")]),n._v(" "),a("ul",[a("li",[n._v("position：absolute")]),n._v(" "),a("li",[n._v("display：inline-block")]),n._v(" "),a("li",[n._v("float：left/right")]),n._v(" "),a("li",[n._v("overflow：hidden")])]),n._v(" "),a("p",[n._v("方式很多但是要找好场景使用。")]),n._v(" "),a("h2",{attrs:{id:"margin-合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#margin-合并"}},[n._v("#")]),n._v(" margin 合并")]),n._v(" "),a("p",[n._v("指两个兄弟层级的标签当设置 margin 的时候两个发生合并。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        div {\n            width: 100px;\n            height: 100px;\n        }\n\n\n\n        .demo1 {\n            background: #000;\n            margin-bottom: 100px;\n        }\n\n        .demo2 {\n            background: #f00;\n            margin-bottom: 100px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="demo1"></div>\n    <div class="demo2"></div>\n</body>\n\n</html>\n')])])]),a("p",[n._v("解决方式：\n通过计算的方式将 margin 放到同一个盒子上")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("margin-bottom:200px;\n")])])]),a("p",[n._v("通过 BFC 的方式使其中一个盒子处于BFC 的规则之下")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        html,body{\n            height: 100%;\n        }\n\n        div {\n            width: 100px;\n            height: 100px;\n        }\n\n\n\n        .demo1 {\n            background: #000;\n            margin-bottom: 100px;\n        }\n\n        .wrapper {\n            overflow: hidden;\n            width: 200px;\n            height: 200px;\n        }\n\n        .demo2 {\n            background: #f00;\n            margin-top: 100px;\n        }\n\n        \n    </style>\n</head>\n\n<body>\n    <div class="demo1"></div>\n    <div class="wrapper">\n        <div class="demo2"></div>\n    </div>\n</body>\n\n</html>\n')])])]),a("p",[n._v("注意：一般我们这种bug 不解决，为什么呢？ 因为BFC需要增加新的 html，我们可以通过其他的方式来绕过这个问题。")]),n._v(" "),a("h2",{attrs:{id:"浮动-float"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮动-float"}},[n._v("#")]),n._v(" 浮动 float")]),n._v(" "),a("p",[n._v("浮动元素产生了浮动流\n所有产生了浮动流的元素，块级元素看不到\n产生了bfc的元素和文本类属性的元素以及文本都能看到浮动元素。\n文本类属性就是（inline/inline-block/text）")]),n._v(" "),a("p",[n._v("假设我们有这样一个结构：父盒子由子盒子撑开内容区，当我们给子盒子设置 float 的时候产生了“浮动流”，此时父盒子将失去内容区。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        html,\n        body {\n            height: 100%;\n        }\n\n        div {\n            background: #000;\n        }\n\n        .parent {\n            border: 1px solid #f00;\n            background: transparent;\n        }\n\n        .parent div {\n            width: 100px;\n            height: 100px;\n            float: left;\n        }\n    </style>\n</head>\n\n<body>\n    <div class="parent">\n        <div class="demo1"></div>\n        <div class="demo2"></div>\n        <div class="demo3"></div>\n    </div>\n</body>\n\n</html>\n')])])]),a("p",[n._v("解决：\n1、通过直接给盒子设置宽高，但是这样如果盒子的数量超过了父盒子的高度将不适用\n2、通过在父盒子末尾添加一个新的标签，通过 clear 清除改标签周围的浮动。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('<style>\n   .parent p {\n            clear: both|left; \n        }\n</style>\n\n<div class="parent">\n        <div class="demo1"></div>\n        <div class="demo2"></div>\n        <div class="demo3"></div>\n        <p></p>\n    </div>\n')])])]),a("p",[n._v("如果我们将 p 标签的clear 设置为 right 意味着我们将会清除 p 标签周围 float:right  的浮动，但是没有 所以失效，并没有什么体现。 但是如果这样解决我们的结构就变得不合理")]),n._v(" "),a("p",[n._v("3、通过伪元素清除浮动")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('.parent::after {\n            content: "";\n            display: block;\n            clear: both;\n        }\n')])])]),a("p",[a("strong",[n._v("注意：如果我们不设置display：block的话没有生效，原因是因为 clear 属性必须作用在块级元素上。")]),n._v("\n4、将父盒子设置为 bfc 元素")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(".parent {\n            border: 1px solid #f00;\n            background: transparent;\n            /* float: left; */\n            /* position: absolute; */\n            /* display: inline-block; */\n        }\n")])])]),a("p",[a("strong",[n._v("注意：position:absolute; float：left/right;在内部会将元素转换成 inline-block")])])])}),[],!1,null,null,null);t.default=i.exports}}]);