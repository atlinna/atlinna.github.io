(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{688:function(e,t,n){"use strict";n.r(t);var r=n(10),l=Object(r.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"树形结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#树形结构"}},[e._v("#")]),e._v(" 树形结构")]),e._v(" "),n("p",[e._v("树形结构 大名叫做 "),n("strong",[e._v("有向无环图")]),e._v("，树是图的一种。")]),e._v(" "),n("p",[e._v("树形结构的特点：")]),e._v(" "),n("ul",[n("li",[e._v("树形结构有一个根节点")]),e._v(" "),n("li",[e._v("树形结构没有回路")]),e._v(" "),n("li",[e._v("根节点为树的根")]),e._v(" "),n("li",[e._v("叶子节点 指的是下面没有其他节点")]),e._v(" "),n("li",[e._v("节点：既不是根节点，又不是叶子节点的普通节点")])]),e._v(" "),n("p",[e._v("树的度：")]),e._v(" "),n("p",[e._v("这棵树有最多叉的节点有多少个叉这棵树的度就是多少")]),e._v(" "),n("p",[e._v("树的深度：")]),e._v(" "),n("p",[e._v("树最深有几层，树的深度就为几。")]),e._v(" "),n("h3",{attrs:{id:"二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[e._v("#")]),e._v(" 二叉树")]),e._v(" "),n("p",[e._v("什么是二叉树呢？")]),e._v(" "),n("p",[e._v("二叉树指的就是"),n("strong",[e._v("树的度")]),e._v("最多为2的树形结构。")]),e._v(" "),n("p",[e._v("二叉树的根节点就是树的根")]),e._v(" "),n("p",[e._v("二叉树的子节点是指某个节点下面的节点")]),e._v(" "),n("p",[e._v("父节点：是指某个节点的上一级节点。")]),e._v(" "),n("p",[e._v("叶子节点同上，指下面没有其他节点")]),e._v(" "),n("p",[e._v("满二叉树：")]),e._v(" "),n("ul",[n("li",[e._v("所有的叶子节点都在最底层。")]),e._v(" "),n("li",[e._v("每个非叶子结点都有两个子节点。")])]),e._v(" "),n("h3",{attrs:{id:"完全二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树"}},[e._v("#")]),e._v(" 完全二叉树")]),e._v(" "),n("p",[e._v("国内定义：")]),e._v(" "),n("ul",[n("li",[e._v("叶子结点都在最后一层或者倒数第二层")]),e._v(" "),n("li",[e._v("叶子结点都向左聚拢")])]),e._v(" "),n("p",[e._v("国际定义：")]),e._v(" "),n("ul",[n("li",[e._v("叶子节点都在最后一层或倒数第二层（相同）")]),e._v(" "),n("li",[e._v("如果有叶子节点，就必须有两个叶子节点。")])]),e._v(" "),n("p",[e._v("在二叉树中，每个节点都认为自己是根节点。 像链表一样")]),e._v(" "),n("p",[e._v("因为二叉树中每个节点只知道自己的子节点，并不知道自己的父节点是谁。")]),e._v(" "),n("h3",{attrs:{id:"子树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#子树"}},[e._v("#")]),e._v(" 子树：")]),e._v(" "),n("p",[e._v("子树的概念是相对的。")]),e._v(" "),n("p",[e._v("如果说有这样一个树结构")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\t\t\t      A\n\t\t\t  |       |\n\t\t\t  B       C\n\t\t\t|   |   |   |\n\t\t\tD   E   F   G\n")])])]),n("p",[e._v("A是根节点对吧")]),e._v(" "),n("p",[e._v("BC 是节点")]),e._v(" "),n("p",[e._v("DEFG 是叶子节点")]),e._v(" "),n("p",[e._v("这是一个完全二叉树")]),e._v(" "),n("p",[e._v("然后呢每个节点都认为自己是根节点")]),e._v(" "),n("p",[e._v("于是 对于 根节点A来说")]),e._v(" "),n("p",[e._v("BDE 这个树结构是 左子树 ，CFG 这个树结构是右子树")]),e._v(" "),n("p",[e._v("相对于节点 B 来讲")]),e._v(" "),n("p",[e._v("D 是 B 的左子树 E 是 B 的右子树。")]),e._v(" "),n("p",[e._v("C 节点同理。")]),e._v(" "),n("h3",{attrs:{id:"二叉树的遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的遍历"}},[e._v("#")]),e._v(" 二叉树的遍历")]),e._v(" "),n("p",[e._v("前序遍历：先根次序遍历")]),e._v(" "),n("p",[e._v("指先打印根节点，然后是左子节点，最后是右子节点")]),e._v(" "),n("p",[e._v("中序遍历：中根次序遍历")]),e._v(" "),n("p",[e._v("指先打印左子节点，然后是根节点，然后是右子节点")]),e._v(" "),n("p",[e._v("后续遍历：后根次序遍历")]),e._v(" "),n("p",[e._v("指先打印左子节点，然后是右子节点，最后是根节点。")]),e._v(" "),n("p",[n("strong",[e._v("但是要注意不要将视角只局限于当前的数，因为数结构中还包含子树。")])]),e._v(" "),n("p",[e._v("练习一下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\t\t\t      A\n\t\t\t  |       |\n\t\t\t  B       C\n\t\t\t|   |   |   |\n\t\t\tD   E   F   G\n")])])]),n("p",[e._v("还是这颗熟悉的满二叉树。写出他的，前序遍历、中序遍历、后序遍历。")]),e._v(" "),n("p",[e._v("前序遍历：ABDECFG")]),e._v(" "),n("p",[e._v("分析：")]),e._v(" "),n("p",[e._v("首先我们看整体的树结构")]),e._v(" "),n("p",[e._v("根节点是A 于是第一个是根节点 A 对吧 ，然后是打印左子节点")]),e._v(" "),n("p",[e._v("这个时候我们应该将视角放到左子树 BDE 中了")]),e._v(" "),n("p",[e._v("根据前序遍历的特点先打印根节点 B 对吧，然后看 B 下面还有子树吗 没有了，于是就是左节点 D 然后是右节点E 所以 分析到当前，我们的遍历次序应该是 ABDE。")]),e._v(" "),n("p",[e._v("然后我们看 A 的右子树，首先 按照前序遍历的特点 先打印根节点 C 然后看 C节点下是否存在子树 好没有，于是开始打印左子节点 F 然后是 右子节点 G")]),e._v(" "),n("p",[e._v("于是整体就是 ：ABDECFG")]),e._v(" "),n("p",[e._v("挺简单的吧")]),e._v(" "),n("p",[e._v("中序遍历：DBEAFCG")]),e._v(" "),n("p",[e._v("分析：")]),e._v(" "),n("p",[e._v("还是先看整体的树结构。 按照中序遍历的特点我们是不是要先打印左子节点，对于根节点下面存在子树的情况要先找子树，好我们开始")]),e._v(" "),n("p",[e._v("首先是根节点 A ，先打印左子节点 B 对吧，但是 B 节点下还存在 子节点，这是一个子树，于是我们先把A 放着 看B 相对于B来说 B 的子节点不存在子树 按照中序遍历的特点，先打印左子节点 D 然后是 根节点 B 然后是右子节点E B 子树看完 我们回到 A 此时 A 的左边 已经遍历完成只需要把A 放到后面是不是就行了。于是遍历到当前是 DBEA。")]),e._v(" "),n("p",[e._v("然后我们看A 的右边 同理，存在子树看子树，直到找到存在叶子节点的那一级，就是 C 对吧 于是按照中序遍历的特点 先打印左子树 F 然后是根节点C 最后是右子节点G")]),e._v(" "),n("p",[e._v("最后打印的结果就是 ：DBEAFCG")]),e._v(" "),n("p",[e._v("后序遍历：DEBFGCA")]),e._v(" "),n("p",[e._v("根据前面两个的分析，")]),e._v(" "),n("p",[n("strong",[e._v("首先 因为每个树节点都认为自己是根节点对吧，所以一个完整的树结构是可能存在子树的，当我们判断当前节点的时候一定要看下面是否存在子树。")])]),e._v(" "),n("p",[e._v("OK 了解了概念，我们来看下具体用代码如何遍历二叉树。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function TreeNode(value, left = null, right = null) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n}\nfunction initTree() {\n  let A = new TreeNode("A");\n  let B = new TreeNode("B");\n  let C = new TreeNode("C");\n  let D = new TreeNode("D");\n  let E = new TreeNode("E");\n  let F = new TreeNode("F");\n  let G = new TreeNode("G");\n  A.left = B;\n  A.right = C;\n  B.left = D;\n  B.right = E;\n  C.left = F;\n  C.right = G;\n}\n')])])]),n("p",[e._v("然后根据我们上面的数结构，构建一个关系树。")]),e._v(" "),n("h4",{attrs:{id:"前序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前序遍历"}},[e._v("#")]),e._v(" 前序遍历")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function frontEach(treeNode) {\n  if (!treeNode) return;\n  console.log(treeNode.value);\n  frontEach(treeNode.left);\n  frontEach(treeNode.right);\n}\n")])])]),n("p",[e._v("完整代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function TreeNode(value, left = null, right = null) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n}\nfunction initTree() {\n  let A = new TreeNode("A");\n  let B = new TreeNode("B");\n  let C = new TreeNode("C");\n  let D = new TreeNode("D");\n  let E = new TreeNode("E");\n  let F = new TreeNode("F");\n  let G = new TreeNode("G");\n  A.left = B;\n  A.right = C;\n  B.left = D;\n  B.right = E;\n  C.left = F;\n  C.right = G;\n\n  frontEach(A);\n}\n\nfunction frontEach(treeNode) {\n  if (!treeNode) return;\n  console.log(treeNode.value);\n  frontEach(treeNode.left);\n  frontEach(treeNode.right);\n}\n\ninitTree();\n')])])]),n("h4",{attrs:{id:"中序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#中序遍历"}},[e._v("#")]),e._v(" 中序遍历")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function centerEach(treeNode) {\n  if (!treeNode) return;\n  centerEach(treeNode.left);\n  console.log(treeNode.value);\n  centerEach(treeNode.right);\n}\n")])])]),n("h4",{attrs:{id:"后序遍历"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#后序遍历"}},[e._v("#")]),e._v(" 后序遍历")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function lastEach(treeNode) {\n  if (!treeNode) return;\n  lastEach(treeNode.left);\n  lastEach(treeNode.right);\n  console.log(treeNode.value);\n}\n")])])]),n("h4",{attrs:{id:"还原二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#还原二叉树"}},[e._v("#")]),e._v(" 还原二叉树")]),e._v(" "),n("p",[n("strong",[e._v("根据前序中序还原二叉树并写出后续遍历")])]),e._v(" "),n("p",[e._v("前序遍历：ABDECFG")]),e._v(" "),n("p",[e._v("中序遍历：DBEAFCG")]),e._v(" "),n("p",[e._v("分析：")]),e._v(" "),n("p",[e._v("首先我们知道前序遍历的规则是先根节点然后是左子树右子树，所以前序遍历的第一个节点一定是树的根节点 A，好我们有了树的根节点，再来看中序遍历，中序遍历是先打印左子树然后是根节点然后是右子树。而我们从前序遍历知道了树的根节点是 A 那么 根节点两边里的就是他的左右子树。")]),e._v(" "),n("p",[e._v("前序遍历：A BDE CFG")]),e._v(" "),n("p",[e._v("中序遍历：DBE A FCG")]),e._v(" "),n("p",[e._v("大概就是这样的，然后先看左子树")]),e._v(" "),n("p",[e._v("也就是这半部分。（含根节点）")]),e._v(" "),n("p",[e._v("前序遍历：A BDE")]),e._v(" "),n("p",[e._v("中序遍历：DBE A")]),e._v(" "),n("p",[e._v("左子树的前序遍历，第一个是根节点，所以 B 是左子树的根节点，后面的一个节点应该是左子节点对吧，然后观察树的中序遍历，中序遍历的第一个节点是左子节点，发现两两对应，D是左子树 BDE 的 左子节点，根据前序遍历特点，左子节点后面的应该是右子节点，对应中序遍历中 根节点右边的是右子节点，所以 E 是 左子树 BDE 的右子节点。现在应该是这样的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\t\t\t\tA\n\t\t\t  |\t\t\t\t\n\t\t\t  B       \n\t\t\t|   |  \n\t\t\tD   E   \n")])])]),n("p",[e._v("然后我们看右子树 CFG，首先根据前序遍历，第一个是根节点，然后我们回到中序遍历中找到根节点 C ，C的左边是左子树，右边是右子树。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\t\t\t      A\n\t\t\t  |       |\n\t\t\t  B       C\n\t\t\t|   |   |   |\n\t\t\tD   E   F   G\n")])])]),n("p",[e._v("那么这颗树的后序遍历就是 DEBFGCA")]),e._v(" "),n("p",[n("strong",[e._v("根据中序后序还原二叉树")])]),e._v(" "),n("p",[e._v("中序遍历：DBEAFCG")]),e._v(" "),n("p",[e._v("后序遍历：DEBFGCA")]),e._v(" "),n("p",[e._v("分析：")]),e._v(" "),n("p",[e._v("首先我们根据后序遍历的特点判断，后序遍历是最后一个是根节点，那么 A 就是根节点，然后我们去中序遍历中 找到 根节点 A 那么 A 左边的就是左子树，A右边的就是右子树，中后序遍历的节点数是一致的，那么我们就能根据中序遍历得到后序遍历中左右子树的长度对吧，")]),e._v(" "),n("p",[e._v("中序遍历：DBE A FCG")]),e._v(" "),n("p",[e._v("后序遍历：DEB FGC A")]),e._v(" "),n("p",[e._v("然后进入到后续遍历的子树中，先左子树，因为最后一个是根节点，所以 B 是左子树的根节点，D是左子节点，E是右子节点，然后是 右子树遍历，最后一个是C，那么左边的F是左子节点，G是右子节点。")]),e._v(" "),n("h4",{attrs:{id:"使用代码还原二叉树"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用代码还原二叉树"}},[e._v("#")]),e._v(" 使用代码还原二叉树")]),e._v(" "),n("p",[n("strong",[e._v("根据前序中序还原二叉树")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function TreeNode(value, left = null, right = null) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n}\n\nlet frontEach = ["A", "B", "D", "E", "C", "F", "G"];\nlet centerEach = ["D", "B", "E", "A", "F", "C", "G"];\n\nfunction reduction(front, center) {\n  if (\n    !front ||\n    !center ||\n    front.length !== center.length ||\n    front.length == 0 ||\n    center.length == 0\n  )\n    return null;\n  let root = new TreeNode(front[0]);\n  let i = center.indexOf(front[0]);\n  let front_left_tree = front.slice(1, i + 1);\n  let front_right_tree = front.slice(i + 1, front.length);\n  let center_left_tree = center.slice(0, i);\n  let center_right_tree = center.slice(i + 1, center.length);\n  root.left = reduction(front_left_tree, center_left_tree);\n  root.right = reduction(front_right_tree, center_right_tree);\n  return root;\n}\n')])])]),n("p",[n("strong",[e._v("根据中序后续还原二叉树")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function TreeNode(value, left = null, right = null) {\n  this.value = value;\n  this.left = left;\n  this.right = right;\n}\n\nlet backEach = ["D", "E", "B", "F", "G", "C", "A"];\nlet centerEach = ["D", "B", "E", "A", "F", "C", "G"];\n\nfunction reduction(center, back) {\n  if (\n    !back ||\n    !center ||\n    back.length !== center.length ||\n    back.length == 0 ||\n    center.length == 0\n  )\n    return null;\n  let root = new TreeNode(back[back.length - 1]);\n  let i = center.indexOf(back[back.length - 1]);\n\n  let center_left_tree = center.slice(0, i);\n  let center_right_tree = center.slice(i + 1, center.length);\n\n  let back_left_tree = back.slice(0, i);\n  let back_right_tree = back.slice(i, back.length - 1);\n\n  root.left = reduction(center_left_tree, back_left_tree);\n  root.right = reduction(center_right_tree, back_right_tree);\n  return root;\n}\n\n\n')])])]),n("h4",{attrs:{id:"二叉树的搜索"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的搜索"}},[e._v("#")]),e._v(" 二叉树的搜索")]),e._v(" "),n("p",[e._v("二叉树的搜索可以扩展为树的搜索、图的搜索、爬虫的逻辑、搜索引擎的爬虫算法。")]),e._v(" "),n("p",[e._v("1、深度优先搜索")]),e._v(" "),n("p",[e._v("深度优先搜索更适合探索未知。即优先走一条线")]),e._v(" "),n("p",[e._v("2、广度优先搜索")]),e._v(" "),n("p",[e._v("广度优先搜索适合探索局域。即查找同一平面。一个范围。")]),e._v(" "),n("p",[e._v("代码实现深度优先搜索：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const { TreeNode } = require("./utils.js");\n\nfunction initTree() {\n  let A = new TreeNode("A");\n  let B = new TreeNode("B");\n  let C = new TreeNode("C");\n  let D = new TreeNode("D");\n  let E = new TreeNode("E");\n  let F = new TreeNode("F");\n  let G = new TreeNode("G");\n  A.left = B;\n  A.right = C;\n  B.left = D;\n  B.right = E;\n  C.left = F;\n  C.right = G;\n\n  console.log(deepSearch(A, "N"));\n}\n\nfunction deepSearch(node, target) {\n  if (!node) return false;\n  if (node && node.value === target) return true;\n  let left_ret = deepSearch(node.left, target);\n  let right_ret = deepSearch(node.right, target);\n  return left_ret || right_ret;\n}\n\ninitTree();\n\n')])])]),n("p",[e._v("通过代码我们可以发现，二叉树的深度优先搜索是不是和前序遍历的顺序是一样的？")]),e._v(" "),n("p",[e._v("代码实现广度优先搜索：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const { TreeNode } = require("./utils.js");\nfunction initTree() {\n  let A = new TreeNode("A");\n  let B = new TreeNode("B");\n  let C = new TreeNode("C");\n  let D = new TreeNode("D");\n  let E = new TreeNode("E");\n  let F = new TreeNode("F");\n  let G = new TreeNode("G");\n  A.left = B;\n  A.right = C;\n  B.left = D;\n  B.right = E;\n  C.left = F;\n  C.right = G;\n\n  console.log(bredthSearch([A], "N"));\n}\n\nfunction bredthSearch(nodeList, target) {\n  if (nodeList.length == 0 || !nodeList) return false;\n  let ret = [];\n  for (let i = 0; i < nodeList.length; i++) {\n    if (!nodeList[i]) {\n      continue;\n    } else if (nodeList[i].value === target) {\n      return true;\n    } else {\n      ret.push(nodeList[i].left);\n      ret.push(nodeList[i].right);\n    }\n  }\n  return bredthSearch(ret, target);\n}\n\ninitTree();\n\n')])])]),n("h4",{attrs:{id:"二叉树的比较"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的比较"}},[e._v("#")]),e._v(" 二叉树的比较")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const { TreeNode } = require("./utils.js");\nlet A1 = new TreeNode("A");\nlet B1 = new TreeNode("B");\nlet C1 = new TreeNode("C");\nlet D1 = new TreeNode("D");\nlet E1 = new TreeNode("E");\nlet F1 = new TreeNode("F");\nlet G1 = new TreeNode("G");\nA1.left = B1;\nA1.right = C1;\nB1.left = D1;\nB1.right = E1;\nC1.left = F1;\n// C1.right = G1;\n\nlet A2 = new TreeNode("A");\nlet B2 = new TreeNode("B");\nlet C2 = new TreeNode("C");\nlet D2 = new TreeNode("D");\nlet E2 = new TreeNode("E");\nlet F2 = new TreeNode("F");\nlet G2 = new TreeNode("G");\nA2.left = B2;\nA2.right = C2;\nB2.left = D2;\nB2.right = E2;\nC2.left = F2;\n// C2.right = G2;\n\nfunction compareTree(tree1, tree2) {\n  if (tree1 == tree2) return true;\n  if ((tree1 && !tree2) || (!tree1 && tree2) || tree1.value !== tree2.value)\n    return false;\n  let left_tree = compareTree(tree1.left, tree2.left);\n  let right_tree = compareTree(tree1.right, tree2.right);\n  return left_tree && right_tree;\n}\n\nlet r = compareTree(A1, A2);\nconsole.log(r);\n\n')])])]),n("p",[n("strong",[e._v("注意：")])]),e._v(" "),n("p",[e._v("遇到二叉树比较的问题时，必须要确定，左右两颗子树如果交换位置，即左右互换算不算同一颗二叉树。")]),e._v(" "),n("p",[e._v("如果是笔试的话，没有特殊说明左右互换还是同一颗树，那么默认互换后不是同一颗树。（尽量还是问下面试官。）")]),e._v(" "),n("p",[e._v("上述代码是 当二叉树互换不是同一颗树的情况。")]),e._v(" "),n("p",[e._v("那么我们怎么来比较左右子树互换的二叉树呢？")]),e._v(" "),n("p",[e._v("只需要在代码上稍微改动一下")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function compareTree(tree1, tree2) {\n  if (tree1 == tree2) return true;\n  if ((tree1 && !tree2) || (!tree1 && tree2) || tree1.value !== tree2.value)\n    return false;\n  let same_tree =\n    compareTree(tree1.left, tree2.left) &&\n    compareTree(tree1.right, tree2.right);\n  let different_tree =\n    compareTree(tree1.left, tree2.right) &&\n    compareTree(tree1.right, tree2.left);\n  return same_tree || different_tree;\n}\n")])])]),n("p",[e._v("假设 我们 先判断 相同的树，不同的话就会去判断 不同的树比较，比较的规则是 tree1 的左子树和 tree2 的右子树相比，如果这个不同的话另一边是不是不用看了 对吧？ 如果相同那么根据二叉树的特点，另一边肯定是相同的。")]),e._v(" "),n("h4",{attrs:{id:"二叉树-diff-算法-diff-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二叉树-diff-算法-diff-dom"}},[e._v("#")]),e._v(" 二叉树 diff 算法 （diff dom）")]),e._v(" "),n("p",[e._v("我们看下虽然我们能够比较出两颗二叉树之间是否是相同的，但是我们不能知道不同的地方在哪里？ 也就是 这棵树新增了什么、删除了什么、修改了什么。如果是在 dom 中使用，我们是不是要知道 dom 结构到底经历了什么样的变化啊。")]),e._v(" "),n("p",[e._v("所以，我们来看看 树的 diff 算法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const { TreeNode } = require("./utils");\nlet A1 = new TreeNode("A");\nlet B1 = new TreeNode("B");\nlet C1 = new TreeNode("C");\nlet D1 = new TreeNode("D");\nlet E1 = new TreeNode("E");\nlet F1 = new TreeNode("F");\nlet G1 = new TreeNode("G");\nA1.left = B1;\nA1.right = C1;\nB1.left = D1;\nB1.right = E1;\nC1.left = F1;\nC1.right = G1;\n\nlet A2 = new TreeNode("A");\nlet B2 = new TreeNode("B");\nlet C2 = new TreeNode("C");\nlet D2 = new TreeNode("D");\nlet E2 = new TreeNode("E");\nlet F2 = new TreeNode("F");\nlet G2 = new TreeNode("G");\nA2.left = B2;\nA2.right = C2;\nB2.left = D2;\nB2.right = E2;\nC2.left = F2;\nC2.right = G2;\n\n/**\n 我们希望得到的是不是一个 装有 新增、修改、删除的一个节点的集合，\n 如 :\n { type:\'add\',old:B,now:C },\n { type:\'delete\',old:B,now:C },\n { type:\'modify\',old:B,now:C },\n 这样能更好的让我们进行下面的逻辑，\n 对比 dom 的操作\n */\nlet diffList = [];\nfunction diffTree(node1, node2, diffList) {\n  if (node1 == node2) {\n    return diffList;\n  } else if (!node1 && node2) {\n    diffList.push({ type: "add", old: null, now: node2 });\n  } else if (node1 && !node2) {\n    diffList.push({ type: "delete", old: node1, now: null });\n  } else if (node1.value != node2.value) {\n    diffList.push({ type: "modify", old: node1, now: node2 });\n  } else {\n    diffTree(node1.left, node2.left, diffList);\n    diffTree(node1.right, node2.right, diffList);\n  }\n}\n\ndiffTree(A1, A2, diffList);\nconsole.log(diffList);\n')])])]),n("p",[e._v("这样我们就能得到一颗 装有状态和新旧节点的 一个 array ，这个 array 将会告诉我们 树改变了什么。")]),e._v(" "),n("p",[e._v("但是现在这个 diff 算法有一些问题，假设，我们将 右子树根节点 C 改变，再将下面的子节点改变。就无法 diff 出子节点的变化。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('let A2 = new TreeNode("A");\nlet B2 = new TreeNode("B");\nlet C2 = new TreeNode("N");\nlet D2 = new TreeNode("D");\nlet E2 = new TreeNode("E");\nlet F2 = new TreeNode("F");\nlet G2 = new TreeNode("M");\n// diff 出的结果只有 C 变为 N\n')])])]),n("p",[e._v("思考一下为什么会这个样子？ 我们肯定是要拿到完整的树结构变化的，不能说 我的父节点变了，我子节点就不管了。")]),e._v(" "),n("p",[e._v("是的")]),e._v(" "),n("p",[e._v("是的")]),e._v(" "),n("p",[e._v("因为我们发现，在修改的时候，如果这是叶子节点还好说，如果是根节点的话，那么就不会继续 diff 子节点了 对吧，所以呢 我们要让他继续 diff。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('else if (node1.value != node2.value) {\n    diffList.push({ type: "modify", old: node1, now: node2 });\n  }\n')])])]),n("p",[e._v("修改后：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function diffTree(node1, node2, diffList) {\n  if (node1 == node2) {\n    return diffList;\n  } else if (!node1 && node2) {\n    diffList.push({ type: "add", old: null, now: node2 });\n  } else if (node1 && !node2) {\n    diffList.push({ type: "delete", old: node1, now: null });\n  } else if (node1.value != node2.value) {\n    diffList.push({ type: "modify", old: node1, now: node2 });\n    diffTree(node1.left, node2.left, diffList);\n    diffTree(node1.right, node2.right, diffList);\n  } else {\n    diffTree(node1.left, node2.left, diffList);\n    diffTree(node1.right, node2.right, diffList);\n  }\n}\n')])])]),n("p",[e._v("是不是 当我们 push 一个修改状态的时候，还需要继续 diff 下面的 子节点啊")])])}),[],!1,null,null,null);t.default=l.exports}}]);