(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{650:function(e,t,n){"use strict";n.r(t);var s=n(10),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"promise-面试题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise-面试题"}},[e._v("#")]),e._v(" Promise 面试题")]),e._v(" "),n("p",[e._v("进入事件队列的函数有以下几种：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("setTimeout")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),n("li",[n("code",[e._v("setInterval")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),n("li",[n("code",[e._v("Promise")]),e._v(" 的 then` 函数回调，微任务（micro task）")]),e._v(" "),n("li",[n("code",[e._v("requestAnimationFrame")]),e._v(" 的回调，宏任务（macro task）")]),e._v(" "),n("li",[e._v("事件处理函数，宏任务（macro task）\n"),n("strong",[e._v("微队列要优先于宏队列")])])]),e._v(" "),n("h3",{attrs:{id:"异步队列探索"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#异步队列探索"}},[e._v("#")]),e._v(" 异步队列探索")]),e._v(" "),n("p",[n("code",[e._v("Promise")]),e._v(" 回调与 "),n("code",[e._v("MutationObserver")]),e._v(" 回调会放入微队列中执行。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('function onMicroTask(callback) {\n\t// 判断是否为 node 环境，process.nextTick 会执行微队列\n  if (process && process.nextTick) {\n    process.nextTick(callback);\n  } else if (MutationObserver) {\n    // 浏览器 MutationObserver 回调会放入微队列执行。\n    const ele = document.createElement("p");\n    const observer = new MutationObserver(callback);\n    observer.observe(ele, { attributes: true });\n    ele.style.width = 1;\n  } else {\n    setTimeout(callback, 0);\n  }\n}\n')])])]),n("h3",{attrs:{id:"promise-手写"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise-手写"}},[e._v("#")]),e._v(" Promise 手写")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('const PENDDING = Symbol("pendding");\nconst FUFILLED = Symbol("fufilled");\nconst REJECTED = Symbol("rejected");\n\nclass MyPromise {\n  /**\n   *\n   * @param {Function} excutor 执行器，用来标记任务的状态\n   */\n  constructor(excutor) {\n    this._status = PENDDING; // 任务状态\n    this._value = undefined; // 任务数据\n    // 如果 Promise 内部报错，将直接调用 reject\n    try {\n      // 由于我们的 resolve、reject 是在class中 会启用严格模式，且被直接调用，this 隐式丢失\n      excutor(this._resolve.bind(this), this._reject.bind(this));\n    } catch (reason) {\n      this._reject(reason);\n    }\n  }\n  /**\n   * 改变状态\n   * @param {Symbol} status\n   * @param {any} value\n   */\n  _changeStatus(status, value) {\n    // 状态只能由未决变为已决，且只能改变一次\n    if (this._status != PENDDING) return;\n    this._status = status;\n    this._value = value;\n  }\n  /**\n   *\n   * @param {any} data 标记任务成功\n   */\n  _resolve(data) {\n    this._changeStatus(FUFILLED, data);\n  }\n  /**\n   *\n   * @param {any} reason 标记任务失败\n   */\n  _reject(reason) {\n    this._changeStatus(REJECTED, reason);\n  }\n}\n\nconst p = new MyPromise((resolve, reject) => {\n  reject("hello");\n  resolve(1);\n});\n\nconsole.log(p);\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);