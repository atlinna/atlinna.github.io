(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{658:function(t,a,e){"use strict";e.r(a);var s=e(10),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"更多的集合类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#更多的集合类型"}},[t._v("#")]),t._v(" 更多的集合类型")]),t._v(" "),e("h3",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[t._v("#")]),t._v(" set")]),t._v(" "),e("p",[e("code",[t._v("set")]),t._v(" 用于存放不重复的数据集合。\n创建方式："),e("code",[t._v("var set = new Set()")])]),t._v(" "),e("p",[t._v("如果传入的数组中有重复数据，回默认去重")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var arr = [1,1,2,3,4,5,5]\nvar set = new Set(arr);\nconsole.log(set) // [1,2,3,4,5]\n")])])]),e("h4",{attrs:{id:"set操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set操作"}},[t._v("#")]),t._v(" set操作")]),t._v(" "),e("ul",[e("li",[e("p",[e("code",[t._v("add(data)")]),t._v(" 向"),e("code",[t._v("set")]),t._v("集合的末尾添加数据。（如果数据已存在于 set 集合中，则不会再添加一项。）")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("set")]),t._v(" 集合判断数据相同是使用 "),e("code",[t._v("Object.is()")]),t._v(" （但是除了 +0 与 -0）")])])]),t._v(" "),e("li",[e("p",[t._v("delete(data) 删除集合中的"),e("code",[t._v("data")])])]),t._v(" "),e("li",[e("p",[t._v("clear() 清空集合")])]),t._v(" "),e("li",[e("p",[t._v("has(data) 判断"),e("code",[t._v("set")]),t._v(" 集合中是否存在"),e("code",[t._v("data")]),t._v(" 数据。")])]),t._v(" "),e("li",[e("p",[t._v("size 得到集合中的成员数量。"),e("strong",[t._v("不允许赋值。")])])])]),t._v(" "),e("h3",{attrs:{id:"set实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set实现"}},[t._v("#")]),t._v(" set实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class MySet {\n  constructor(iterator = []) {\n    // 判断是否是可迭代的对象\n    if (typeof iterator[Symbol.iterator] != "function") {\n      throw new TypeError("你提供的不是一个可迭代对象！");\n    }\n    this._datas = [];\n    for (const item of iterator) {\n      this.add(item);\n    }\n  }\n  add(data) {\n    if (!this.has(data)) {\n      this._datas.push(data);\n    }\n  }\n  has(data) {\n    for (const item of this._datas) {\n      if (this.isEqual(data, item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  delete(data) {\n    for (let i = 0; i < this._datas.length; i++) {\n      if (this.isEqual(data, this._datas[i])) {\n        this._datas.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n  clear() {\n    this._datas.length = 0;\n  }\n  isEqual(data1, data2) {\n    if (data1 == 0 && data2 === 0) {\n      return true;\n    }\n    return Object.is(data1, data2);\n  }\n  *[Symbol.iterator](){\n    for(const item of this._datas){\n        yield item;\n    }\n  }\n  get size(){\n    return this._datas.length;\n  }\n}\n')])])]),e("h3",{attrs:{id:"map集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map集合"}},[t._v("#")]),t._v(" Map集合")]),t._v(" "),e("p",[e("code",[t._v("map")]),t._v("集合专门用于存储多个键值对数据。")]),t._v(" "),e("p",[t._v("使用对象存储有以下问题：")]),t._v(" "),e("ul",[e("li",[t._v("键名只能是字符串")]),t._v(" "),e("li",[t._v("获取数据的数量不方便")]),t._v(" "),e("li",[t._v("键名容易和原型上的名称冲突")])]),t._v(" "),e("h4",{attrs:{id:"如何创建-map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何创建-map"}},[t._v("#")]),t._v(" 如何创建 Map")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const map = new Map() // 创建一个空的 Map\n")])])]),e("p",[t._v("初始化Map需要传入一个数组，数组内成员为一个长度为2的数组，第一项为键名，第二项为键值。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const initMap = new Map([['a',1],['b',2],['c',3]]) // \n")])])]),e("h4",{attrs:{id:"操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),e("ul",[e("li",[t._v("size 获取 Map 的键值对的数量。")]),t._v(" "),e("li",[t._v("set(键，值) 设置一个键值对，键和值可以是任意类型。\n"),e("ul",[e("li",[t._v("如果键存在，则修改。")]),t._v(" "),e("li",[t._v("如果键不存在，则增加。")]),t._v(" "),e("li",[t._v("比较键的方式和 Set 相同。均使用 Object.is 判断是否相同。")])])]),t._v(" "),e("li",[t._v("get(键)  根据键名得到对应的值。")]),t._v(" "),e("li",[t._v("has(键)  判断键是否存在。")]),t._v(" "),e("li",[t._v("delete(键)  删除指定的键。")])]),t._v(" "),e("h3",{attrs:{id:"map实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map实现"}},[t._v("#")]),t._v(" Map实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class MyMap {\n  constructor(iterator = []) {\n    if (typeof iterator[Symbol.iterator] != "function") {\n      throw new TypeError(iterator + "不是可迭代对象");\n    }\n    this._datas = [];\n    for (const item of iterator) {\n      if (typeof item[Symbol.iterator] != "function") {\n        throw new TypeError(item + "不是可迭代对象");\n      }\n      const ite = item[Symbol.iterator]()\n      const key = ite.next().value;\n      const value = ite.next().value;\n      this.set(key, value);\n    }\n  }\n  _getObj(key) {\n    for (const item of this._datas) {\n      if (this.isEqual(item.key, key)) {\n        return item;\n      }\n    }\n    return undefined;\n  }\n  isEqual(data1, data2) {\n    if (data1 === 0 && data2 === 0) {\n      return true;\n    }\n    return Object.is(data1, data2);\n  }\n  set(key, value) {\n    const obj = this._getObj(key);\n    if (obj) {\n      obj.value = value;\n    } else {\n      this._datas.push({ key, value });\n    }\n  }\n  has(key) {\n    return !!this._getObj(key);\n  }\n  get(key){\n    const obj = this._getObj(key);\n    if(obj){\n        return obj.value;\n    }\n  }\n  delete(key){\n    for(var i = 0;i<this._datas.length;i++){\n        const ele = this._datas[i];\n        if(this.isEqual(ele.key,key)){\n            this._datas.splice(i,1);\n        }\n    }\n  }\n  clear(){\n    this._datas.length = 0;\n  }\n  *[Symbol.iterator](){\n    for(const item of this._datas){\n        yield [item.key,item.value]\n    }\n  }\n}\n')])])]),e("h3",{attrs:{id:"weakset-weakmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakset-weakmap"}},[t._v("#")]),t._v(" WeakSet && WeakMap")]),t._v(" "),e("h4",{attrs:{id:"weakset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[t._v("#")]),t._v(" WeakSet")]),t._v(" "),e("p",[t._v("与 set 基本完全相同")]),t._v(" "),e("p",[t._v("不同点：")]),t._v(" "),e("ul",[e("li",[t._v("内部存储的对象地址不会影响垃圾回收。即"),e("strong",[t._v("对象引用消失，WeakSet中的成员也会消失。")])]),t._v(" "),e("li",[t._v("只能添加对象")]),t._v(" "),e("li",[t._v("不能遍历、没有 size 属性、")])]),t._v(" "),e("h4",{attrs:{id:"weakmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[t._v("#")]),t._v(" WeakMap")]),t._v(" "),e("p",[t._v("与 map 基本完全相同")]),t._v(" "),e("p",[t._v("不同点：")]),t._v(" "),e("ul",[e("li",[t._v("键不会影响垃圾回收。")]),t._v(" "),e("li",[t._v("键必须是对象。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);