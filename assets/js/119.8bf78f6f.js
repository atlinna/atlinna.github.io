(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{762:function(t,a,s){"use strict";s.r(a);var v=s(10),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"什么是模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是模块化"}},[t._v("#")]),t._v(" 什么是模块化")]),t._v(" "),s("div",{staticClass:"language-markdown extra-class"},[s("pre",{pre:!0,attrs:{class:"language-markdown"}},[s("code",[t._v("将一个复杂的程序按照一定的规则封装成杰哥文件，并进行组合在一起。每个模块的内部数据是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信\n")])])]),s("h2",{attrs:{id:"模块化的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化的优点"}},[t._v("#")]),t._v(" 模块化的优点")]),t._v(" "),s("ol",[s("li",[t._v("避免命名空间的冲突（减少命名空间的污染）")]),t._v(" "),s("li",[t._v("更好的分离，实现按需加载")]),t._v(" "),s("li",[t._v("提高代码的复用性")]),t._v(" "),s("li",[t._v("提高代码的维护性")])]),t._v(" "),s("h3",{attrs:{id:"发展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#发展"}},[t._v("#")]),t._v(" 发展")]),t._v(" "),s("ul",[s("li",[t._v("2022年 正式提出命名空间模式")]),t._v(" "),s("li",[t._v("2009年 提出 CommonJS 规范")]),t._v(" "),s("li",[t._v("2009年 提出 AMD 规范")]),t._v(" "),s("li",[t._v("2011年 提出 UMD 规范")]),t._v(" "),s("li",[t._v("2011年 提出 CMD 规范")]),t._v(" "),s("li",[t._v("2015年 提出 ES2015 Modules 规范")])]),t._v(" "),s("h3",{attrs:{id:"扩展"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#扩展"}},[t._v("#")]),t._v(" 扩展")]),t._v(" "),s("ul",[s("li",[t._v("CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD\nCMD解决方案。")]),t._v(" "),s("li",[t._v("AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。")]),t._v(" "),s("li",[t._v("CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM\n打包，模块的加载逻辑偏重")]),t._v(" "),s("li",[t._v("ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD\n规范，成为浏览器和服务器通用的模块解决方案。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);