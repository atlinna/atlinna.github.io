(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{717:function(n,t,r){"use strict";r.r(t);var e=r(10),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"前缀和数组"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前缀和数组"}},[n._v("#")]),n._v(" 前缀和数组")]),n._v(" "),r("p",[n._v("不使用前缀和:")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("var NumArray = function(nums) {\n    this.nums = nums;\n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {number}\n */\nNumArray.prototype.sumRange = function(left, right) {\n    var count = 0;\n    while (left <= right) {\n        if (left == right) {\n            count += this.nums[left];\n            break;\n        }\n        count = count + this.nums[left] + this.nums[right];\n        left++;\n        right--;\n    }\n    return count;\n};\n")])])]),r("p",[n._v("使用前缀和：")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("var NumArray = function (nums) {\n    this.preNums = new Array(nums.length + 1).fill(0);\n    this.preNums[1] = nums[0];\n    for (var i = 2; i < this.preNums.length; i++) {\n        this.preNums[i] = this.preNums[i - 1] + nums[i - 1]\n    }\n};\n\n/** \n * @param {number} left \n * @param {number} right\n * @return {number}\n */\nNumArray.prototype.sumRange = function (left, right) {\n    return this.preNums[right + 1] - this.preNums[left]\n};\n")])])]),r("p",[n._v("如果多次调用 sumRange 方法，那么他的时间复杂度就是 O(n)。我们需要让时间复杂度变为 O（1）。\n通过 preNums 数组来存储第 0 项 到 第 i 项的和， 这样，如果我们取范围内的和就相当于用当前位置的和 "),r("strong",[n._v("减去")]),n._v(" 前一项的和，即为范围内的和。")])])}),[],!1,null,null,null);t.default=s.exports}}]);