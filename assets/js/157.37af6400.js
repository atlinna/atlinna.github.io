(window.webpackJsonp=window.webpackJsonp||[]).push([[157],{743:function(n,e,a){"use strict";a.r(e);var s=a(10),t=Object(s.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"设计模式-单例模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式-单例模式"}},[n._v("#")]),n._v(" 设计模式-单例模式")]),n._v(" "),a("p",[n._v("单例模式属于创造类型的模式，研究的是对象的创建。")]),n._v(" "),a("p",[n._v("定义：")]),n._v(" "),a("p",[n._v("保证一个类仅有一个实例，并提供一个访问他的全局访问点。")]),n._v(" "),a("p",[n._v("顾名思义，是一个仅需要实例化一次的构造函数。")]),n._v(" "),a("p",[n._v("如果你是进行一个小型的网页开发，多创建一个两个的对象，对性能的消耗根本就是那种无关紧要的对吧，一两个对象才消耗多少性能。这种情况不适合。")]),n._v(" "),a("p",[n._v("如果是一种大型的站点，比方说 wechat，假设现在有一个用户，用户需要登录，并且要保证他在一定事件内登录有效。")]),n._v(" "),a("p",[n._v("你说这种登录功能，你能多次登录吗？这种要求是不是仅需要实例化一次就足以了")]),n._v(" "),a("p",[n._v("假设我们现在要开发一款贪吃蛇的游戏对吧，当你的蛇吃到小点点，会变大。但是，贪吃蛇这个本体，是不是也仅需要在开始游戏的时候实例化一次啊？")]),n._v(" "),a("p",[n._v("接下来我们看看如何创建一个单例模式。")]),n._v(" "),a("h3",{attrs:{id:"单例模式的创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式的创建"}},[n._v("#")]),n._v(" 单例模式的创建")]),n._v(" "),a("p",[n._v("我们的单例模式的原则是什么？")]),n._v(" "),a("p",[a("strong",[n._v("一个构造函数有且仅能创建一个实例。")])]),n._v(" "),a("p",[n._v("假设我们有两个变量 a、b ，我们的 a 通过 new 实例化可以得到一个实例，然后 b 通过同样的操作也能得到一个实例，且 a === b")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("第一种实现方式")]),n._v(" "),a("p",[n._v("首先我们回顾一下 new 操作符对构造函数进行了哪些操作？ 或者说 new 操作符做了什么事？")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function Person(name){\n\t// 创建了一个对象，然后对象继承构造函数的原型，\n\t// 改变 this 到这个对象，为对象添加属性。\n\t// 实际上是不是下面的这行代码，\n\t// this = Object.create(Person.prototype)\n\t.\n\t.\n\t.\n\t// 最后 如果没有对象返回就返回 this \n\t// return this\n}\n")])])]),a("p",[n._v("也就是说我们的实现其实只是填充中间那部分对吧？ 其他的操作已经通过new 操作符隐式的完成了。")]),n._v(" "),a("p",[n._v("Ok 那我们来吧！")]),n._v(" "),a("p",[n._v("我们如果想让一个构造函数返回的是相同的实例。")]),n._v(" "),a("p",[n._v("是不是最后 return 的 this 必须是相同的，也就是说我们需要一个地方来存放我们首次创建的 this。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\t\t\t// 实现方式 1\n        function Person(name) {\n            if (Person.self) {\n                return Person.self\n            }\n            Person.self = this;\n            this.name = name;\n        }\n\n        var a = new Person('zhang san');\n        var b = new Person('');\n        console.log(a === b); // true\n")])])]),a("p",[n._v("但是这种方式不好，为什么说他不好呢？")]),n._v(" "),a("p",[n._v("他违反了我们设计模式六大原则中的开闭原则。因为他将这个实例完全的暴露出来。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\t\t\t\tvar a = new Person('zhang san');\n        Person.self = {};\n        var b = new Person('');\n        console.log(a === b);\n")])])]),a("p",[n._v("如上，我将 Person 的 self 属性重新赋值为一个空对象 {} 那么当你第二次进行实例化的时候，返回的 是 {} 而不是首次实例化的 this")])]),n._v(" "),a("li",[a("p",[n._v("第二种实现方式")]),n._v(" "),a("p",[n._v("使用闭包的方式，保存一个变量。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("        // 实现方式 2\n        function Person(name) {\n            var self = this;\n            this.name = name;\n            Person =  function (){\n                return self\n            }\n        }\n\n        var a = new Person('zhang san');\n        var b = new Person();\n        console.log(a === b);\n")])])]),a("p",[n._v("这种方式其实也不是很好，为什么这么说呢？")]),n._v(" "),a("p",[n._v("比方说我们除了用到这个实例，还想用到他的原型链。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("        // 实现方式 2\n        function Person(name) {\n            var self = this;\n            this.name = name;\n            Person = function () {\n                return self\n            }\n        }\n\n        var a = new Person('zhang san');\n        Person.prototype.id = '10010';\n        var b = new Person();\n        console.log(a === b, a.id, b.id); // true undefined undefined\n")])])]),a("p",[n._v("我们在实例化 a 后保存了 一个 ID 到 他的原型链上。但是我们发现 诶 ，在 a，b 上根本取不到这个值。")]),n._v(" "),a("p",[n._v("这是为什么呢？")]),n._v(" "),a("p",[n._v("因为我们在首次实例化后，由于 self 保存了 我们的实例，Person 重新赋值 成为了新的函数，也就是 那个匿名函数，然后当我们给 Person 的原型链添加属性的时候，实际上添加的是匿名函数的原型。而不是我们的 原Person函数（构造出实例的那个函数）")]),n._v(" "),a("p",[n._v("所以这个方案，我们也 pass 掉。")])]),n._v(" "),a("li",[a("p",[n._v("第三种实现方式")]),n._v(" "),a("p",[n._v("这次我们通过一个立即执行函数来保存实例")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("        var Person = (function () {\n            return ...\n        })()\n")])])]),a("p",[n._v("我们 变量 Person 的内容是不是就是 这个立即执行函数返回的内容")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("        // 实现方式 3\n        var Person = (function () {\n            var self = null;\n            return function (name) {\n                if (self) {\n                    return self;\n                }\n                self = this;\n                this.name = name;\n            }\n        })()\n\n        var a = new Person('zhang san');\n        Person.prototype.id = '10010';\n        var b = new Person();\n\n        console.log(a === b, a.id, b.id)\n")])])]),a("p",[n._v("这次，我们创建实例的构造函数保持一致，且变量也持久化。")])])]),n._v(" "),a("h3",{attrs:{id:"单例模式生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单例模式生成器"}},[n._v("#")]),n._v(" 单例模式生成器")]),n._v(" "),a("p",[n._v("我们知道了如何创建单例模式，但是，创建他的话是不是不小的手笔。")]),n._v(" "),a("p",[n._v("所以我们为了解决它，让不会使用，不知道的人也能得到一个单例模式。我们就需要封装一个生成器。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("        var getSingle = function (func) {\n            var ret = null;\n            return function () {\n                if (!ret) {\n                    ret = func.apply(this, arguments)\n                }\n                return ret;\n            }\n        }\n")])])])])}),[],!1,null,null,null);e.default=t.exports}}]);