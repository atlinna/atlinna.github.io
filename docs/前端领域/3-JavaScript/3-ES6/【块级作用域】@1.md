## 块级作用域

什么是块级作用域？

代码执行时遇到花括号，会创建一个块级作用域，花括号结束（相当于函数执行结束），销毁块级作用域。

`let` 与 `const` 解决了什么问题

+ 全局变量挂载到全局对象，造成了全局对象成员污染
+ var 重复的声明变量，导致数据被覆盖
+ 变量提升。

### let

+ `let` 声明的变量不会挂载到全局对象中
+ `let` 声明的变量不允许在当前作用域重复声明。
+ `let` 声明的变量只能作用于当前作用域，作用域外无法访问。
+ `let` 声明的变量不能在定义之前使用。

`let` 声明的变量实际上也会提升，但是提升之后会将其放入到 `暂时性死区` ,如果访问的变量位于暂时性死区，则会报错，只有当代码运行到该变量的声明语句时，才会将其从暂时性死区中移除。

**暂时性死区，相当于一个内存空间。**

使用 `let` 声明的循环变量，每次进入循环体都会重新开启一个新的作用域，并将循环变量绑定到该作用域。**意味着每次循环，使用的都是一个全新的循环变量。**

在循环中使用 `let` 声明的循环变量，在循环结束后会销毁。

### const

`const` 与 `let` 完全相同。

唯一的区别是 `const` 必须在声明时赋值，且不能改变

`const` 只能保证内存空间中的值不变，不能保证内存空间中地址指向的位置的值不变。

