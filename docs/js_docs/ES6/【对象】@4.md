## 对象

### Object.is

等效于 `===` 

但是除了两种情况

+ NaN == NaN  // false  							Object.is(NaN,NaN) 				// true
+ +0 == -0          // true                               Object.is(+0,-0)                                 // false

### Object.setPrototypeof

`Object.setPrototypeof(obj1,obj2)` 表示将 obj2 设置为 obj1 的隐式原型



### Object.getOwnPropertyNames

该 Api 之前就存在，只是 ES6 对其进行了升级，将返回的属性名数组进行了排序。规则如下：

+ 先排序数字 。 -- 先把数字放到前面
+ 再排字母。      -- 按照原来的顺序把字母的key 放到后面
+ 再排其他。      -- 。。。



## 类 （Class）

### 类的书写方式（Class 语法糖）

使用 Class关键字来声明类，使用 constructor 来定义类的构造函数。定义的函数会放到类的原型中。

```
Class A{
	constructor(name,age){
		this.name = name;
		this.age = age;
	}
	// 方法定义，会放到 A.prototype 上，
	print(){
	
	}
}
```

### getter & setter

在方法名前加上 get、set 关键字来定义 getter 和 setter。

使用 getter 和 setter 控制的属性，不在原型上。

```
Class A{
	constructor(name){
		this.name = name;
	}
	// 使用 get 关键字定义 getter
	get age(){
		return this.age;
	}
	// 使用 set 关键字定义 setter
	set age(age){
		this.age = age;
	}
}
```

getter 和 setter 的本质实际上是使用 Object.defineProperty 来定义属性的getter 和 setter，只不过是帮你封装成了一个函数。

```
Class A{
	constructor(name){
		this.name = name;
		// 实质。
		Object.defineProperty(this,'age',{
			getter:function (){
				return 
			},
			setter:function (val){
				this.age = val;
			}
		})
	}
}
```

### 静态成员

构造函数本身的成员，自己的成员。

使用 static 关键字来定义。

```
Class A{
	static a = 1;
	static methods(){
	
	}
}
A.a // 1
A.methods() //
```

### 字段初始化器(ES7)

+ 使用 static 的字段初始化器，添加的是静态成员
+ 没有使用 static 的字段初始化器，添加的成员位于对象上，即创建出来的实例每个都有。
+ 箭头函数在字段初始化器位置上，指向当前对象。

```
Class A{
 	static a = 1; // 静态成员
 	b = 2;
 	c = 3;
 	print = () =>{
 		
 	}
 	// 相当于 下面这种写法。
 	constructor(){
 		this.b = 2;
 		this.c = 3;
 		this.print = ()=>{} // 箭头函数的this由定义的位置决定。
 	}
 	
 	
}
```

